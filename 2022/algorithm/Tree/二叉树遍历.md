本篇开始总结二叉树的常用解题技巧，二叉树的顺序遍历和层序遍历刚好对应深度优先搜索和广度优先搜索。


## 1 顺序遍历
**题目列表**
<blockquote><ul> 
<li><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank">144. 前序遍历</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank">145. 二叉树的后序遍历
</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">94. 二叉树的中序遍历</a></p></li>
</ul></blockquote> 


**144. 二叉树的前序遍历**
给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

<img src ="https://img-blog.csdnimg.cn/d930b0ad0a4b415f9f733d06abd1efe1.jpeg#pic_center" width = 10%>

示例 1：
输入：root = [1,null,2,3]
输出：[1,2,3]

示例 2：
输入：root = []
输出：[]

**1. 递归实现**

递归算法三要素：确定递归函数的参数和返回值、确定终止条件、确定单层递归的逻辑

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        # 递归法
        if not root: return []
        result = []
        def traversal(root):
            if not root: return
            result.append(root.val)                 # 先将根节点值加入结果
            if root.left: traversal(root.left)      # 左
            if root.right: traversal(root.right)    # 右
        traversal(root)
        return self.result 
```

**2. 迭代实现**

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        # 迭代法
        if not root: return []
        stack = [root]
        res = []
        while stack:
            node = stack.pop()
            res.append(node.val)
            if node.right: stack.append(node.right)
            if node.left: stack.append(node.left)
        return res
```

<img src ="https://img-blog.csdnimg.cn/59e36f298d0e4f9c8989b25c83da1104.gif#pic_center" width = 48%>

**94. 二叉树的中序遍历**

给你二叉树的根节点 root ，返回它节点值的 中序 遍历。

<img src ="https://img-blog.csdnimg.cn/d930b0ad0a4b415f9f733d06abd1efe1.jpeg#pic_center" width = 10%>

示例 1：
输入：root = [1,null,2,3]
输出：[1,3,2]

示例 2：
输入：root = []
输出：[]

**1. 递归实现**

```python
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        result = []

        def traversal(root: TreeNode):
            if root == None:
                return
            traversal(root.left)    # 左
            result.append(root.val) # 中序
            traversal(root.right)   # 右

        traversal(root)
        return result
```

**2. 迭代实现**

中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。

那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        if not root:    return []   # 空树
        stack = []                  # 不能提前将root结点加入stack中'
        res = []
        cur = root
        while cur or stack:
            if cur:                 # 先迭代访问最底层左子树结点
                stack.append(cur)
                cur = cur.left
            else:                   # 到达最左节点后处理栈顶结点
                cur = stack.pop()
                res.append(cur.val)
                cur = cur.right     # 取栈顶元素右结点
        return res
```

<img src ="https://img-blog.csdnimg.cn/7b72fa8097f947e58e29191b61d3415b.gif#pic_center" width = 48%>


**145. 二叉树的后序遍历**
给你二叉树的根节点 root ，返回它节点值的 后序 遍历。

<img src ="https://img-blog.csdnimg.cn/d930b0ad0a4b415f9f733d06abd1efe1.jpeg#pic_center" width = 10%>

示例 1：
输入：root = [1,null,2,3]
输出：[3,2,1]

示例 2：
输入：root = []
输出：[]


**1. 递归实现**

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        # 递归遍历
        if not root: return []
        result = []

        def traversal(root: Optional[TreeNode])-> List[int]:
            if not root: return
            self.traversal(root.left)               # 左
            self.traversal(root.right)              # 右
            self.result.append(root.val)            # 中
        traversal(root)
        return result
```

**2. 迭代实现**

后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：

<img src ="https://img-blog.csdnimg.cn/88c1c7df1a7749b6b20e5bcf34d43919.png#pic_center" width = 48%>

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        # 迭代遍历
        if not root: return []
        stack = [root]
        result = []
        while stack:
            node = stack.pop()
            result.append(node.val)
            if node.left: stack.append(node.left)
            if node.right: stack.append(node.right)
        return result[::-1]
```

## 3 层序遍历

<blockquote><ul> 
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank">102. 二叉树的层序遍历</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank">107. 二叉树的层次遍历II</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank">199. 二叉树的右视图</a></p></li>
<li><p><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank">637.二叉树的层平均值</a></p></li>
<li><p><a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank">429. N叉树的层序遍历/a></p></li>
<li><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank">515. 在每个树行中找最大值</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">116. 填充每个节点的下一个右侧节点指针</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">117.填充每个节点的下一个右侧节点指针II</a></a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">104. 二叉树的最大深度</a></p></li>
<li><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank">111. 二叉树的最小深度</a></p></li>
</ul></blockquote> 


**102. 二叉树的层序遍历**

给你二叉树的根节点 root ，返回其节点值的层序遍历。（即逐层地，从左到右访问所有节点）。

<img src ="https://img-blog.csdnimg.cn/77657ad157bb4bddb2787ecd6281f44b.jpeg#pic_center" width = 16%>

> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。

需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。

而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

使用队列实现二叉树广度优先遍历，动画如下：

<img src ="https://img-blog.csdnimg.cn/051d01a3b12b4aa9974c5ffcc9d3355d.gif#pic_center" width = 16%>

**1. 迭代遍历**

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 二叉树层序遍历迭代解法
        if not root: return []
        results = []
        que = deque([root])
        while que:
            size = len(que)
            result = []
            for _ in range(size):       # 这里一定要使用固定大小size，不要使用len(que)，因为len(que)是不断变化的
                cur = que.popleft()
                result.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            results.append(result)
        return results
```

**2. 递归遍历**

用广度优先处理是很直观的，可以想象成是一把刀横着切割了每一层，但是深度优先遍历就不那么直观了。

<img src ="https://img-blog.csdnimg.cn/a7eae8c3694542628f74cf48ea137020.jpeg#pic_center" width = 48%>

我们开下脑洞，把这个二叉树的样子调整一下，摆成一个田字形的样子。田字形的每一层就对应一个 list。

<img src ="https://img-blog.csdnimg.cn/5b3e6d1287c0436cba55f19ca4a7d920.jpeg#pic_center" width = 48%>

按照深度优先的处理顺序，会先访问节点 1，再访问节点 2，接着是节点 3。 之后是第二列的 4 和 5，最后是第三列的 6。

每次递归的时候都需要带一个 index(表示当前的层数)，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。

动态演示如下：

<img src ="https://img-blog.csdnimg.cn/2555389f901d4d0bb1e020fb5e619a09.gif#pic_center" width = 48%>

```python
class Solution(object):
	def levelOrder(self, root):
		"""
		:type root: TreeNode
		:rtype: List[List[int]]
		"""
		if not root:
			return []
		res = []
		def dfs(index, r):
			# 假设 res 是 [[1], [2,3]]， index 是 3，就再插入一个空 list 放到 res 中
			if len(res) < index:
				res.append([])
			#  将当前节点的值加入到res中，index代表当前层，假设 index 是3，节点值是99
			# res是 [[1], [2,3], [4]]，加入后res就变为 [[1], [2,3], [4,99]]
			res[index-1].append(r.val)
			# 递归的处理左子树，右子树，同时将层数index+1
			if r.left:
				dfs(index+1, r.left)
			if r.right:
				dfs(index+1, r.right)
		dfs(1, root)
		return res
```

**107. 二叉树的层次遍历II**

给你二叉树的根节点 root ，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

<img src ="https://img-blog.csdnimg.cn/c87bcb6a27ce4d6dba93a28f558dc184.jpeg#pic_center" width = 64%>

> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[15,7],[9,20],[3]]


```python
from collections import deque
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root: return []
        results = []
        que = deque([root])
        while que:
            size = len(que)
            result = []
            for _ in range(size):
                node = que.popleft()
                result.append(node.val)
                if node.left: que.append(node.left)
                if node.right: que.append(node.right)
            results.append(result)
        results.reverse()
        return results
```


**199. 二叉树的右视图**

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

<img src ="https://img-blog.csdnimg.cn/6a5a2767dce54d67b3b52074e6ebe2b1.jpeg#pic_center" width = 64%>

> 输入: [1,2,3,null,5,null,4]
> 输出: [1,3,4]

```python
from collections import deque
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root: return []
        res = []
        # # deque相比list的好处是，list的pop(0)是O(n)复杂度，deque的popleft()是O(1)复杂度
        que = deque([root])
        while que:
            res.append(que[-1].val)         # 每次都取最后一个node就可以
            size = len(que)
            for _ in range(size):           # 执行这个遍历的目的是获取下一层所有的node
                node = que.popleft()
                if node.left: que.append(node.left)
                if node.right: que.append(node.right)
        return res
```


**637. 二叉树的层平均值**

给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。

<img src ="https://img-blog.csdnimg.cn/ceca6038c1234c568b41d5707ac293b8.jpeg#pic_center" width = 16%>

> 输入：root = [3,9,20,null,null,15,7]
> 输出：[3.00000,14.50000,11.00000]
> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。

**方法一：广度优先搜索**

```python
from collections import deque
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        result = []
        que = deque([root])
        while que:
            size = len(que)
            total = 0
            for _ in range(size):
                cur = que.popleft()
                total += cur.val
                if cur.left: que.append(cur.left)
                if cur.right: que.append(cur.right)
            result.append(total/size)
        return result
```

**方法二：深度优先搜索**





**429. N叉树的层序遍历**

给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

<img src ="https://img-blog.csdnimg.cn/3da46491dd0d4fdabdb5bc69c5447821.png#pic_center" width = 16%>

> 输入：root = [1,null,3,2,4,null,5,6]
> 输出：[[1],[3,2,4],[5,6]]

```python

```



**515. 在每个树行中找最大值**

给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。

<img src ="https://img-blog.csdnimg.cn/ebbd2e21a0ac4b608d9818d8684acb33.jpeg#pic_center" width = 48%>

> 输入: root = [1,3,2,5,3,null,9]
> 输出: [1,3,9]



