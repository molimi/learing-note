数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。

双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 1 常用技巧
### 1.1 滑动窗口



### 1.2 双指针


### 1.3 前缀和数组



### 1.4 差分数组

差分数组是与前缀和数组所对应的一种逆操作，类似于求导和积分，也就是说，对差分数组求前缀和，可以得到原数组，同样的，对前缀和数组求差分，也可以得到原数组。

差分数组的性质是：当我们希望对原数组的某一个区间[i, j]施加一个增量 inc 时，差分数组d对应的变化是：d[i]增加inc，d[j+1]减少inc，并且这种操作是可以叠加的。

下面举个例子：

<img src ="https://img-blog.csdnimg.cn/83077c9e4b54423397418b869910227b.png#pic_center" width = 64%>

差分数组是一个辅助数组，从侧面来表示给定某一数组的变化，一般用来对数组进行区间修改的操作。

还是上面那个表里的例子，我们需要进行以下操作：
1. 将区间[1，4]的数值全部加上3
2. 将区间[3，5]的数值全部减去5

很简单对吧，你可以进行枚举。但是如果给你的数据量是 $1\times e^5$，操作量 $1\times e^5$，限时1000ms你暴力枚举能莽的过去吗？慢到你怀疑人生直接。这时我们就需要使用到差分数组了。

其实当你将原始数组中元素同时加上或者减掉某个数，那么他们的差分数组其实是不会变化的。

利用这个思想，咱们将区间缩小，缩小的例子中的区间 [1,4] 吧这是你会发现只有 d[1] 和 d[5] 发生了变化，而 d[2], d[3], d[4]却保持着原样，

<img src ="https://img-blog.csdnimg.cn/9ecb494bbaf24dec92c88f3de9d2ab9e.png#pic_center" width = 64%>

进行下一个操作，

<img src ="https://img-blog.csdnimg.cn/1b8075b18478477bbb20549f422a0d6c.png#pic_center" width = 64%>

这时我们就会发现这样一个规律，当对一个区间进行增减某个值的时候，他的差分数组对应的区间左端点的值会同步变化，而他的右端点的后一个值则会相反地变化，其实这个很好理解。

本部分参考自：[差分详解+例题](https://blog.csdn.net/qq_44786250/article/details/100056975)


也就是说，当我们需要对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。所以，差分数组的主要适⽤场景是频繁对原始数组的某个区间的元素进⾏增减，但只能是区间元素同时增加或减少相同的数的情况才能用。

## 2 常见题型
### 2.1 删除数组元素
- 掌握数组删除元素的直接覆盖操作
- 双指针法

题库列表：
<blockquote> 
<ul><li><p>27. <a href="https://leetcode-cn.com/problems/remove-element" target="_blank">移除元素</a> （快慢指针）</p>
<li><p>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank">删除有序数组中的重复项</a> （快慢指针）</p>
<li><p>80. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank">删除有序数组中的重复项 II</a></p></li>
<li><p>75. <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">颜色分类</a>（双指针，三色旗，小米笔试）</p></li></ul>
</blockquote> 

**27. 移除元素**

题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        '''拷贝覆盖'''
        ans = 0
        for num in nums:
            if num!= val:
                nums[ans] = num
                ans += 1
        return ans
```


**26. 删除有序数组中的重复项**

题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 1
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        
        return slow + 1
```
<img src ="https://img-blog.csdnimg.cn/1d4a8c6760ad491db13253c570a055ac.gif#pic_center" width = 48%>




**80. 删除有序数组中的重复项 II**

题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 1, 2
        while fast < len(nums):
            if nums[fast] != nums[slow-1]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return  slow + 1
```
<img src ="https://img-blog.csdnimg.cn/4ed7086e27e04f34bb2a545260cad190.gif#pic_center" width = 48%>

通用解法：
为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。
对于此类问题，我们应该进行如下考虑：

由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。

对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。

此时，初始化时指针 p 指向数组的起始位置（nums[k-1]），指针 q 指向指针 p 的后一个位置（nums[k]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：

- 如果nums[q] ≠ nums[p-k+1]，那么nums[p + 1] = nums[q]；
- 如果nums[q] = nums[p]，那么指针q继续向后查找；


**75. 颜色分类**
题目描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**1. 单指针**

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        i = 0
        length = len(nums)
        for j in range(length):
            if nums[j] == 0:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        for k in range(i, length):
            if nums[k] == 1:
                nums[k], nums[i] = nums[i], nums[k]
                i += 1
```
<img src ="https://img-blog.csdnimg.cn/e394454d9f7045328dd7f7379271dc01.gif#pic_center" width = 48%>

**2. 双指针**

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        # 定义三个变量，p0 表示数组最左边0的区域，p1是数组最右边2的区域
        i, p0, p1 = 0, 0 , len(nums)-1
        while i <= p1:
            # 如果当前指向的是 0，就把这个元素交换到数组左边
			# 也就是跟 p0 指针交换，之后cur，p0 就往前一动一位
            if nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                p0 += 1
                i += 1
            # 如果当前指向的是2，就把这个元素交换到数组右边
			# 也就是跟p2指针交换，注意此时cur指针就不用移动了
			# 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动
            elif nums[i] == 2:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 -= 1
            # 如果是1的话，就不用交换	
            else:
                i += 1
```

<img src ="https://img-blog.csdnimg.cn/1c5e2825d6734c959541f7dac7bc3834.gif#pic_center" width = 48%>


### 2.2 双指针技巧

题库列表：
<blockquote> 
<ul><li><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank">88. 合并两个有序数组</a>：<mark>如何将数组所有元素整体后移，防止数组覆盖？</mark></p></li>
<li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a>（有序数列的首尾双指针）</p></li>
<li><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank">125. 验证回文串</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank">345. 反转字符串中的元音字母</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a>：<strong>经典题目</strong></p></li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a>：<strong>滑动窗口</strong></p></li></ul>
</blockquote> 


**88. 合并两个有序数组**
题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列

**逆向双指针**

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        nums1[m:] = nums2               # 直接合并后排序
        nums1.sort()           
        """
        p0, p1, p2 = m-1, n-1, m+n-1
        while p0 >= 0 or p1 >= 0:
            if p0 == -1:
                nums1[p2] = nums2[p1]
                p1 -= 1
            elif p1 == -1:
                nums1[p2] = nums1[p0]
                p0 -= 1
            elif nums1[p0] > nums2[p1]:
                nums1[p2] = nums1[p0]
                p0 -= 1
            else:
                nums1[p2] = nums2[p1]
                p1 -= 1
            p2 -= 1
```

<img src ="https://img-blog.csdnimg.cn/e774063fb7da49bebb6fc252d8ed82d5.gif#pic_center" width = 48%>

**167. 两数之和 II - 输入有序数组**

题目描述：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        head, tail = 0, len(numbers)-1
        while head < tail:
            two_sum = numbers[head] + numbers[tail]
            if two_sum == target:
                return [head+1, tail+1]
            elif two_sum > target:
                tail -= 1
            else:
                head += 1
```

**125. 验证回文串**

题目描述：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串。字母和数字都属于字母数字字符。

```python
import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        '''
        # 思路一：正则表达式
        if not s:
            return True
        s = s.lower()
        pattern = re.compile(r'[^a-z0-9]')   # 正则表达式，把数字和字母都剔除掉
        new_str = pattern.sub('', s)
        return new_str == new_str[::-1]
        '''
        # 字符串预处理
        new_str = ''.join(ch.lower() for ch in s if ch.isalnum())
        return new_str == new_str[::-1]
```
这里使用了正则表达式移除所有非字母数字字符，然后判断新的字符串是否是回文，也可以使用双指针，直接一次遍历，遇到字母数字字符就进行判断。

**345. 反转字符串中的元音字母**

题目描述：给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现不止一次。

```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        str_set = set("aeiouAEIOU")
        head, tail = 0, len(s) - 1
        str_list = list(s)
        while head < tail:
            if str_list[head] in str_set and str_list[tail] in str_set:
                str_list[head], str_list[tail] = str_list[tail], str_list[head]
                head += 1
                tail -= 1
            elif str_list[head] in str_set and str_list[tail] not in str_set:
                tail -= 1
            elif str_list[head] not in str_set and str_list[tail] in str_set:
                head += 1
            else:
                head += 1
                tail -= 1
        return ''.join(str_list)
```


**11. 盛最多水的容器**

题目描述：给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。


```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        # 双指针，移动小的那一边
        head, tail = 0, len(height)-1
        res = 0
        while head < tail:
            if height[head] < height[tail]:
                res = max(res, height[head]*(tail-head))
                head += 1
            else:
                res = max(res, height[tail]*(tail-head))
                tail -= 1
        return res
```

<img src ="https://img-blog.csdnimg.cn/92c37ceecb7d4b7eb4f57682f1ef2a78.gif#pic_center" width = 48%>



**209. 长度最小的子数组**

题目描述：给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 $[nums_l, nums_{l+1}, ..., nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回 0。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        '''
        我们把数组中的右指针右移，直到总和大于等于 target 为止，记录个数。然后左指针右移，直到队列中元素的和小于 target 为止，记录个数。重复，直到右指针到达队尾。
        '''
        if min(nums) > target or sum(nums) < target:
            return 0
        min_len = inf
        head, tail = 0, 0
        total = 0
        while tail < len(nums):     # 右指针滑动
            total += nums[tail]
            while total >= target:  # 固定右指针，滑动左指针，求最小子数组
                min_len = min(min_len, tail - head + 1)
                total -= nums[head]
                head += 1
            tail += 1

        return min_len
```

56. 合并区间

题目描述：以数组 intervals 表示若干个区间的集合，其中单个区间为 $intervals[i] = [starti, endi]$。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。


```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        result= []
        intervals.sort(key=lambda x:x[0])
        for interval in intervals:
            # 如果列表为空，或者当前区间与上一区间不重合，直接添加
            if not result or result[-1][1] < interval[0]:
                result.append(interval)
            else:
                # 否则的话，我们就可以与上一区间进行合并
                result[-1][1] = max(result[-1][1], interval[1])
        return result
```

### 2.3 剑指offer 数组题

题库列表：
<blockquote> 
<ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank">【剑指 Offer】3. 数组中重复的数字</a>(HashSet 特点)</li><li><a href="https://www.cnblogs.com/gzshan/p/10716061.html" target="_blank">【剑指Offer】4. 二维数组中的查找</a>(首尾双指针)</li><li><a href="https://www.cnblogs.com/gzshan/p/10735252.html" target="_blank">【剑指Offer】11. 旋转数组的最小数字</a>（二分查找）</li><li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank">【剑指Offer 】17. 打印从1到最大的n位数</a>(字符串加法)</li><li><a href="https://www.cnblogs.com/gzshan/p/10764984.html" target="_blank">【剑指Offer】21. 调整数组顺序使奇数位于偶数前面</a>（快排收尾双指针）</li><li><a href="https://www.cnblogs.com/gzshan/p/10783970.html" target="_blank">【剑指Offer】29. 顺时针打印矩阵</a>(打印)</li><li><a href="https://www.cnblogs.com/gzshan/p/10810298.html" target="_blank">【剑指Offer】39. 数组中出现次数超过一半的数字</a>(分治、摩尔投票法)</li><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank">【剑指 Offer】40. 最小的k个数</a>(排序算法、大根堆小根堆)</li><li><a href="https://www.cnblogs.com/gzshan/p/10834178.html" target="_blank">【剑指Offer】51. 数组中的逆序对</a>（归并排序）</li><li><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank">【剑指 Offer】53 - I. 在排序数组中查找数字 I</a>(二分查找缩小范围)</li><li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank">【剑指 Offer 】53 - II. 0～n-1中缺失的数字</a>（二分查找缩小范围）</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank">【剑指 Offer】 56 - I. 数组中数字出现的次数</a>(二进制异或)</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank">【剑指 Offer 】56 - II. 数组中数字出现的次数 II</a>（二进制求和）</li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank">【剑指 Offer】 57. 和为s的两个数字</a>(首尾双指针)</li></ul>
</blockquote> 

**3. 数组中重复的数字**
题目描述：
```python

```




**4. 二维数组中的查找**
题目描述：
```python

```





**11. 旋转数组的最小数字**
题目描述：
```python

```




**17. 打印从1到最大的n位数**
题目描述：
```python

```




**21. 调整数组顺序使奇数位于偶数前面**
题目描述：
```python

```



**29. 顺时针打印矩阵**
题目描述：
```python

```


**39. 数组中出现次数超过一半的数字**
题目描述：
```python

```



**40. 最小的k个数**
题目描述：
```python

```


**51. 数组中的逆序对**
题目描述：
```python

```


**53 - I. 在排序数组中查找数字 I**
题目描述：
```python

```



**53 - II. 0～n-1中缺失的数字**
题目描述：
```python

```




**56 - I. 数组中数字出现的次数**
题目描述：
```python

```



**56 - II. 数组中数字出现的次数 II**
题目描述：
```python

```


**57. 和为s的两个数字**
题目描述：
```python

```





_____

## 参考
- 数组+常见题型与解题策略：[https://blog.csdn.net/qq_42647903/article/details/120594856](https://blog.csdn.net/qq_42647903/article/details/120594856)
- 差分详解+例题：[https://blog.csdn.net/qq_44786250/article/details/100056975](https://blog.csdn.net/qq_44786250/article/details/100056975)
- 滑动窗口算法基本原理与实践：[https://www.cnblogs.com/huansky/p/13488234.html](https://www.cnblogs.com/huansky/p/13488234.html)