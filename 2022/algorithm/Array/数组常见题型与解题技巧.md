数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括对双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。

双指针⼜分为中间向两端扩散的双指针、两端向中间收缩的双指针、快慢指针。此外，数组还有前缀和和差分数组也属于必知必会的算法技巧。

## 1 常用技巧
### 1.1 滑动窗口



### 1.2 双指针


### 1.3 前缀和


### 1.4 差分数组



## 2 常见题型
### 2.1 删除数组元素
- 掌握数组删除元素的直接覆盖操作
- 双指针法

题库列表：
<blockquote> 
<ul><li><p>27. <a href="https://leetcode-cn.com/problems/remove-element" target="_blank">移除元素</a> （快慢指针）</p>
<li><p>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array" target="_blank">删除有序数组中的重复项</a> （快慢指针）</p>
<li><p>80. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii" target="_blank">删除有序数组中的重复项 II</a></p></li>
<li><p>75. <a href="https://leetcode-cn.com/problems/sort-colors/" target="_blank">颜色分类</a>（双指针，三色旗，小米笔试）</p></li></ul>
</blockquote> 

**27. 移除元素**

题目描述：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 $O(1)$ 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        '''拷贝覆盖'''
        ans = 0
        for num in nums:
            if num!= val:
                nums[ans] = num
                ans += 1
        return ans
```


**26. 删除有序数组中的重复项**

题目描述：给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 0, 1
        while fast < len(nums):
            if nums[fast] != nums[slow]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        
        return slow + 1
```
<img src ="https://img-blog.csdnimg.cn/1d4a8c6760ad491db13253c570a055ac.gif#pic_center" width = 48%>




**80. 删除有序数组中的重复项 II**

题目描述：给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 $O(1)$ 额外空间的条件下完成。


```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        slow, fast = 1, 2
        while fast < len(nums):
            if nums[fast] != nums[slow-1]:
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return  slow + 1
```
<img src ="https://img-blog.csdnimg.cn/4ed7086e27e04f34bb2a545260cad190.gif#pic_center" width = 48%>

通用解法：
为了让解法更具有一般性，我们将原问题的「最多保留 1 位」修改为「最多保留 k 位」。
对于此类问题，我们应该进行如下考虑：

由于是保留 k 个相同数字，对于前 k 个数字，我们可以直接保留。

对于后面的任意数字，能够保留的前提是：与当前写入的位置前面的第 k 个元素进行比较，不相同则保留。

此时，初始化时指针 p 指向数组的起始位置（nums[k-1]），指针 q 指向指针 p 的后一个位置（nums[k]）。随着指针 q 不断向后移动，将指针 q 指向的元素与指 p 指向的元素进行比较：

- 如果nums[q] ≠ nums[p-k+1]，那么nums[p + 1] = nums[q]；
- 如果nums[q] = nums[p]，那么指针q继续向后查找；


**75. 颜色分类**
题目描述：给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

**1. 单指针**

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        i = 0
        length = len(nums)
        for j in range(length):
            if nums[j] == 0:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
        for k in range(i, length):
            if nums[k] == 1:
                nums[k], nums[i] = nums[i], nums[k]
                i += 1
```
<img src ="https://img-blog.csdnimg.cn/e394454d9f7045328dd7f7379271dc01.gif#pic_center" width = 48%>

**2. 双指针**

```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        # 定义三个变量，p0 表示数组最左边0的区域，p1是数组最右边2的区域
        i, p0, p1 = 0, 0 , len(nums)-1
        while i <= p1:
            # 如果当前指向的是 0，就把这个元素交换到数组左边
			# 也就是跟 p0 指针交换，之后cur，p0 就往前一动一位
            if nums[i] == 0:
                nums[i], nums[p0] = nums[p0], nums[i]
                p0 += 1
                i += 1
            # 如果当前指向的是2，就把这个元素交换到数组右边
			# 也就是跟p2指针交换，注意此时cur指针就不用移动了
			# 因为右边的一片区域都是2，只要把元素交换过去就可以了，cur不用移动
            elif nums[i] == 2:
                nums[i], nums[p1] = nums[p1], nums[i]
                p1 -= 1
            # 如果是1的话，就不用交换	
            else:
                i += 1
```

<img src ="https://img-blog.csdnimg.cn/1c5e2825d6734c959541f7dac7bc3834.gif#pic_center" width = 48%>


### 2.2 双指针技巧

题库列表：
<blockquote> 
<ul><li><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank">88. 合并两个有序数组</a>：<mark>如何将数组所有元素整体后移，防止数组覆盖？</mark></p></li>
<li><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank">167. 两数之和 II - 输入有序数组</a>（有序数列的首尾双指针）</p></li>
<li><p><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank">125. 验证回文串</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/" target="_blank">345. 反转字符串中的元音字母</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank">11. 盛最多水的容器</a>：<strong>经典题目</strong></p></li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a>：<strong>滑动窗口</strong></p></li></ul>
</blockquote> 


**88. 合并两个有序数组**
题目描述：给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列

**逆向双指针**

```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        nums1[m:] = nums2               # 直接合并后排序
        nums1.sort()           
        """
        p0, p1, p2 = m-1, n-1, m+n-1
        while p0 >= 0 or p1 >= 0:
            if p0 == -1:
                nums1[p2] = nums2[p1]
                p1 -= 1
            elif p1 == -1:
                nums1[p2] = nums1[p0]
                p0 -= 1
            elif nums1[p0] > nums2[p1]:
                nums1[p2] = nums1[p0]
                p0 -= 1
            else:
                nums1[p2] = nums2[p1]
                p1 -= 1
            p2 -= 1
```

<img src ="https://img-blog.csdnimg.cn/e774063fb7da49bebb6fc252d8ed82d5.gif#pic_center" width = 48%>

**167. 两数之和 II - 输入有序数组**

题目描述：给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        head, tail = 0, len(numbers)-1
        while head < tail:
            two_sum = numbers[head] + numbers[tail]
            if two_sum == target:
                return [head+1, tail+1]
            elif two_sum > target:
                tail -= 1
            else:
                head += 1
```

**125. 验证回文串**

题目描述：如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串。字母和数字都属于字母数字字符。

```python
import re
class Solution:
    def isPalindrome(self, s: str) -> bool:
        '''
        # 思路一：正则表达式
        if not s:
            return True
        s = s.lower()
        pattern = re.compile(r'[^a-z0-9]')   # 正则表达式，把数字和字母都剔除掉
        new_str = pattern.sub('', s)
        return new_str == new_str[::-1]
        '''
        # 字符串预处理
        new_str = ''.join(ch.lower() for ch in s if ch.isalnum())
        return new_str == new_str[::-1]
```
这里使用了正则表达式移除所有非字母数字字符，然后判断新的字符串是否是回文，也可以使用双指针，直接一次遍历，遇到字母数字字符就进行判断。

**345. 反转字符串中的元音字母**

题目描述：给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现不止一次。

```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        str_set = set("aeiouAEIOU")
        head, tail = 0, len(s) - 1
        str_list = list(s)
        while head < tail:
            if str_list[head] in str_set and str_list[tail] in str_set:
                str_list[head], str_list[tail] = str_list[tail], str_list[head]
                head += 1
                tail -= 1
            elif str_list[head] in str_set and str_list[tail] not in str_set:
                tail -= 1
            elif str_list[head] not in str_set and str_list[tail] in str_set:
                head += 1
            else:
                head += 1
                tail -= 1
        return ''.join(str_list)
```


**11. 盛最多水的容器**
题目描述：

```python

```

**209. 长度最小的子数组**
题目描述：
```python

```


### 2.3 剑指offer 数组题

题库列表：
<blockquote> 
<ul><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/" target="_blank">【剑指 Offer】3. 数组中重复的数字</a>(HashSet 特点)</li><li><a href="https://www.cnblogs.com/gzshan/p/10716061.html" target="_blank">【剑指Offer】4. 二维数组中的查找</a>(首尾双指针)</li><li><a href="https://www.cnblogs.com/gzshan/p/10735252.html" target="_blank">【剑指Offer】11. 旋转数组的最小数字</a>（二分查找）</li><li><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/" target="_blank">【剑指Offer 】17. 打印从1到最大的n位数</a>(字符串加法)</li><li><a href="https://www.cnblogs.com/gzshan/p/10764984.html" target="_blank">【剑指Offer】21. 调整数组顺序使奇数位于偶数前面</a>（快排收尾双指针）</li><li><a href="https://www.cnblogs.com/gzshan/p/10783970.html" target="_blank">【剑指Offer】29. 顺时针打印矩阵</a>(打印)</li><li><a href="https://www.cnblogs.com/gzshan/p/10810298.html" target="_blank">【剑指Offer】39. 数组中出现次数超过一半的数字</a>(分治、摩尔投票法)</li><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/" target="_blank">【剑指 Offer】40. 最小的k个数</a>(排序算法、大根堆小根堆)</li><li><a href="https://www.cnblogs.com/gzshan/p/10834178.html" target="_blank">【剑指Offer】51. 数组中的逆序对</a>（归并排序）</li><li><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/" target="_blank">【剑指 Offer】53 - I. 在排序数组中查找数字 I</a>(二分查找缩小范围)</li><li><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/" target="_blank">【剑指 Offer 】53 - II. 0～n-1中缺失的数字</a>（二分查找缩小范围）</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/" target="_blank">【剑指 Offer】 56 - I. 数组中数字出现的次数</a>(二进制异或)</li><li><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/" target="_blank">【剑指 Offer 】56 - II. 数组中数字出现的次数 II</a>（二进制求和）</li><li><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/" target="_blank">【剑指 Offer】 57. 和为s的两个数字</a>(首尾双指针)</li></ul>
</blockquote> 

**3. 数组中重复的数字**
题目描述：
```python

```




**4. 二维数组中的查找**
题目描述：
```python

```





**11. 旋转数组的最小数字**
题目描述：
```python

```




**17. 打印从1到最大的n位数**
题目描述：
```python

```




**21. 调整数组顺序使奇数位于偶数前面**
题目描述：
```python

```



**29. 顺时针打印矩阵**
题目描述：
```python

```


**39. 数组中出现次数超过一半的数字**
题目描述：
```python

```



**40. 最小的k个数**
题目描述：
```python

```


**51. 数组中的逆序对**
题目描述：
```python

```


**53 - I. 在排序数组中查找数字 I**
题目描述：
```python

```



**53 - II. 0～n-1中缺失的数字**
题目描述：
```python

```




**56 - I. 数组中数字出现的次数**
题目描述：
```python

```



**56 - II. 数组中数字出现的次数 II**
题目描述：
```python

```


**57. 和为s的两个数字**
题目描述：
```python

```





_____

## 参考
- 数组+常见题型与解题策略：[https://blog.csdn.net/qq_42647903/article/details/120594856](https://blog.csdn.net/qq_42647903/article/details/120594856)