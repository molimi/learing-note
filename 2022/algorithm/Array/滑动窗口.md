&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数组和链表代表着计算机最基本的两种存储形式：顺序存储和链式存储，所以他俩可以算是最基本的数据结构。数组是一种基础数据结构，可以用来处理常见的排序和二分搜索问题，典型的处理技巧包括双指针、滑动窗口等，数组是数据结构中的基本模块之一。因为字符串是由字符数组形成的，所以二者是相似的。

## 1 滑动窗口
### 1.1 定义
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机网络里经常用到滑动窗口协议（Sliding Window Protocol），该协议是 TCP协议 的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认。因此该协议可以加速数据的传输，提高网络吞吐量。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口算法其实和这个是一样的，只是用的地方场景不一样，可以根据需要调整窗口的大小，有时也可以是固定窗口大小。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口使用双指针解决问题，所以一般也叫双指针算法，因为两个指针间形成一个窗口。双指针也并不局限在数组问题，像链表场景的 “快慢指针” 也属于双指针的场景，其快慢指针滑动过程中本身就会产生一个窗口，比如当窗口收缩到某种程度，可以得到一些结论。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color=#9900CC><strong>什么情况适合用双指针呢？</font></strong>

- 需要输出或比较的结果在原数据结构中是连续排列的，特别是数组或链表问题；
- 每次窗口滑动时，只需观察窗口两端元素的变化，无论窗口多长，每次只操作两个头尾元素，当用到的窗口比较长时，可以显著减少操作次数；
- 窗口内元素的整体性比较强，窗口滑动可以只通过操作头尾两个位置的变化实现，但对比结果时往往要用到窗口中所有元素。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口算法常用于字符串匹配问题和子数组问题。

> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。其实这里就可以看出来<font color=#9900CC><strong>滑动窗口主要应用在数组和字符串上。</strong></font>


### 1.2 滑动窗口法的大体框架

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍滑动窗口的框架时候，大家先从字面理解下：
- 滑动：说明这个窗口是移动的，也就是移动是按照一定方向来的。
- 窗口：窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。**滑动窗口算法的思路是这样：**

1. 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。
3. 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

### 1.3 滑动窗口模板
**滑窗模板 Python 伪代码**

```python
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...
```

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口中用到了左右两个指针，它们移动的思路是：以右指针(end)作为驱动，拖着左指针(start)向前走。右指针每次只移动一步，而左指针在内部 while 循环中每次可能移动多步。右指针是主动前移，探索未知的新区域；左指针是被迫移动，负责寻找满足题意的区间。

_____

## 2 常见题型
### 2.1 滑动窗口

题库列表：


<blockquote><ul>
<li><p><a href="https://leetcode.cn/problems/maximum-average-subarray-i/" target="_blank">643. 子数组最大平均数 I</a></p></li>
<li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank">3. 无重复字符的最长子串</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/" target="_blank">159. 至多包含两个不同字符的最长子串</a></p></li>
<li><p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank">209. 长度最小的子数组</a></p></li>
<li><p><a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank">76. 最小覆盖子串</a></p></li>
<li><p><a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank">239. 滑动窗口最大值</a></p></li>
<li><p><a href="https://leetcode.cn/problems/maximum-erasure-value/" target="_blank">1695. 删除子数组的最大得分</a></p></li>
<li><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank">438. 找到字符串中所有字母异位词</a></p></li>
<li><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank">567. 字符串的排列</a></p></li>
<li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-ii/" target="_blank">487. 最大连续1的个数 II</a></p></li>
<li><p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/" target="_blank">1004. 最大连续1的个数 III</a></p></li>
<li><p><a href="https://leetcode.cn/problems/get-equal-substrings-within-budget/" target="_blank">1208. 尽可能使字符串相等</a></p></li>
<li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner/" target="_blank">1052. 爱生气的书店老板</a></p></li>
<li><p><a href="https://leetcode.cn/problems/minimum-swaps-to-group-all-1s-together/" target="_blank">1151. 最少交换次数来组合所有的1 Π</a></p></li>
<li><p><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/" target="_blank">424. 替换后的最长重复字符</a></p></li>
<li><p><a href="https://leetcode.cn/problems/subarrays-with-k-different-integers/" target="_blank">992. K 个不同整数的子数组</a></p></li>
<li><p><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/" target="_blank">1423. 可获得的最大点数</a></p></li>
<li><p><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/" target="_blank">995. K 连续位的最小翻转次数</a></p></li>
</ul></blockquote> 


**643. 子数组最大平均数 I**
题目描述：给你一个由 n 个元素组成的整数数组 nums 和一个整数 k。请你找出平均数最大且 长度为 k 的连续子数组，并输出该最大平均数。



**3. 无重复字符的最长子串**
题目描述：给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        temp_str = ''
        max_len, current_len = 0, 0
        for i in range(len(s)):
            if s[i] not in temp_str:
                temp_str += s[i]
                current_len += 1
            else:
                index = temp_str.index(s[i])
                temp_str = temp_str[index+1:]
                temp_str += s[i]
                current_len = len(temp_str)
            if max_len < current_len:
                max_len = current_len
        
        return max_len
```

**159. 至多包含两个不同字符的最长子串**

题目描述：给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t 。


**209. 长度最小的子数组**

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目描述：给定一个含有 n 个正整数的数组和一个正整数 target。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 $[nums_l, nums_{l+1}, ..., nums_{r-1}, nums_r]$，并返回其长度。如果不存在符合条件的子数组，返回 0。

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        '''
        我们把数组中的右指针右移，直到总和大于等于 target 为止，记录个数；
        然后左指针右移，直到队列中元素的和小于 target 为止，记录个数；
        重复，直到右指针到达队尾。
        '''
        if min(nums) > target or sum(nums) < target:
            return 0
        min_len = inf
        head, tail = 0, 0
        total = 0
        while tail < len(nums):             # 右指针滑动
            total += nums[tail]
            while total >= target:          # 固定右指针，滑动左指针，求最小子数组
                min_len = min(min_len, tail - head + 1)
                total -= nums[head]
                head += 1
            tail += 1

        return min_len
```

**239. 滑动窗口最大值**
题目描述：
<img src ="https://img-blog.csdnimg.cn/6ce90bc0816f4f098903bf117015ad47.png#pic_center" width = 48%>


**76. 最小覆盖子串**

题目描述：给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。
```python
from collections import defaultdict
from math import inf
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need_dict = defaultdict(int)
        for ch in t:
            need_dict[ch] += 1
        need_count = len(t)
        left = 0
        res = (0, inf)
        for right, ch in enumerate(s):
            if need_dict[ch] > 0:           # 不断增加窗口，直到包含所有元素
                need_count -= 1
            need_dict[ch] -= 1              # 这里把用不到的字母也记录下来，利于左指针的移动
            if need_count == 0:             # 此时缩小窗口
                while True:
                    if need_dict[s[left]]==0:
                        break
                    need_dict[s[left]] += 1
                    left += 1
                if right - left < res[1] - res[0]:
                    res = (left, right)
                need_dict[s[left]] += 1
                left += 1
                need_count +=1
        return s[res[0]:res[1]+1] if res[1] < len(s) else ""
```



**1695. 删除子数组的最大得分**

题目描述：给你一个正整数数组 nums ，请你从中删除一个含有 若干不同元素 的子数组。删除子数组的 得分 就是子数组各元素之 和。返回 只删除一个 子数组可获得的 最大得分。如果数组 b 是数组 a 的一个连续子序列，即如果它等于 a[l],a[l+1],...,a[r] ，那么它就是 a 的一个子数组。

**438. 找到字符串中所有字母异位词**

题目描述：给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。


**567. 字符串的排列**

题目描述：给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。



**487. 最大连续1的个数 II**
题目描述：给定一个二进制数组，你可以最多将 1 个 0 翻转为 1，找出其中最大连续 1 的个数。






**1004. 最大连续1的个数 III**
题目描述：给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。




**1208. 尽可能使字符串相等**
题目描述：给你两个长度相同的字符串，s 和 t。将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。
用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。
如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。
如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。



**1052. 爱生气的书店老板**
题目描述：
<img src ="https://img-blog.csdnimg.cn/faf4b3b09c164840947c3a469e3c5d61.png#pic_center" width = 48%>

**1151. 最少交换次数来组合所有的1 Π**


**424. 替换后的最长重复字符**

题目描述：给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。在执行上述操作后，返回包含相同字母的最长子字符串的长度。

**992. K 个不同整数的子数组**
题目描述：给定一个正整数数组 nums和一个整数 k ，返回 num 中 「好子数组」 的数目。如果 nums 的某个子数组中不同整数的个数恰好为 k，则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。
子数组 是数组的 连续 部分。


**1423. 可获得的最大点数**
题目描述：
<img src ="https://img-blog.csdnimg.cn/54c0fa475a0842058868553f260a3057.png#pic_center" width = 48%>



**995. K连续位的最小翻转次数**

<img src ="https://img-blog.csdnimg.cn/15db060c0d70489ea8c29a3388fc3919.png#pic_center" width = 48%>





            
        



____











_____

## 参考
- 双指针套路总结：[https://zhuanlan.zhihu.com/p/95747836](https://zhuanlan.zhihu.com/p/95747836)
- 数组+常见题型与解题策略：[https://blog.csdn.net/qq_42647903/article/details/120594856](https://blog.csdn.net/qq_42647903/article/details/120594856)
- 算法与数据结构（一）：滑动窗口法总结：[https://blog.csdn.net/Dby_freedom/article/details/89066140](https://blog.csdn.net/Dby_freedom/article/details/89066140)
- 滑动窗口法python模板写法：[https://blog.csdn.net/weixin_44414948/article/details/113862173](https://blog.csdn.net/weixin_44414948/article/details/113862173)