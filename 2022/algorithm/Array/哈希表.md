## 1 哈希表

散列表（Hash table，也叫哈希表），是根据关键码值(Key和value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

哈希函数（Hash Function）：将哈希表中元素的关键键值映射为元素存储位置的函数。
哈希冲突（Hash Collision）：不同的关键字通过同一个哈希函数可能得到同一哈希地址。
哈希表的两个核心问题是：「哈希函数的构建」 和 「哈希冲突的解决方法」。

常用的哈希函数方法有：直接定址法、除留余数法、平方取中法、基数转换法、数字分析法、折叠法、随机数法、乘积法、点积法等。

常用的哈希冲突的解决方法有两种：开放地址法和链地址法。


给定表M，存在函数 f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 M 为哈希(Hash)表，函数f(key)为哈希(Hash) 函数。

Python 将哈希表用于字典和集合。 哈希表是键值对的无序集合，其中每个键都是唯一的。 哈希表提供了有效的查找，插入和删除操作的组合。 这些是数组和链接列表的最佳属性。

相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。

而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。



## 2 常见题型
### 2.1 题库列表

<blockquote><ul> 
<li><p><a href="https://leetcode.cn/problems/design-hashset/" target="_blank">705. 设计哈希集合</a></p></li>
<li><p><a href="https://leetcode.cn/problems/design-hashmap/" target="_blank">706. 设计哈希映射</a></p></li>
<li><p><a href="https://leetcode.cn/problems/single-number/" target="_blank">136. 只出现一次的数字</a></p></li>
<li><p><a href="https://leetcode.cn/problems/single-number-ii/" target="_blank">137. 只出现一次的数字 II</a></p></li>
<li><p><a href="https://leetcode.cn/problems/single-number-iii/" target="_blank">260. 只出现一次的数字 III</a></p></li>
<ul><li><p><a href="https://leetcode.cn/problems/contains-duplicate/description/" target="_blank">217. 存在重复元素</a></p></li>
<li><p><a href="https://leetcode.cn/problems/find-the-difference/description/" target="_blank">389. 找不同</a></p></li>
</ul></blockquote> 

**705. 设计哈希集合**

题目描述：

<img src ="https://img-blog.csdnimg.cn/623149b79f2847a39736b281661c8409.png#pic_center" width = 48%>

```python
# 定义一个一维长度为 buckets 的二维数组 table。第一维度用于计算哈希函数，为 key 分桶。
# 第二个维度用于寻找 key 存放的具体位置。第二维度的数组会根据 key 值动态增长，模拟真正的链表。
class MyHashSet:

    def __init__(self):
        self.buckets = 1009
        self.table = [[] for _ in range(self.buckets)]

    def hash(self, key):
        return key % self.buckets           # 用取余数的方法实现集合
    
    def add(self, key):
        hashkey = self.hash(key)
        if key in self.table[hashkey]:
            return
        self.table[hashkey].append(key)
        
    def remove(self, key):
        hashkey = self.hash(key)
        if key not in self.table[hashkey]:
            return
        self.table[hashkey].remove(key)

    def contains(self, key):
        hashkey = self.hash(key)
        return key in self.table[hashkey]
```

**706. 设计哈希映射**

题目描述：
<img src ="https://img-blog.csdnimg.cn/c55e2d1917da487baf6424a8b4b4d2d1.png#pic_center" width = 48%>

```python
class MyHashMap:

    def __init__(self):
        self.buckets = 1009
        self.table = [[] for _ in range(self.buckets)]

    def hash(self, key):                # 哈希映射关系
        return key % self.buckets
    
    def put(self, key: int, value: int) -> None:
        hashkey = self.hash(key)
        for item in self.table[hashkey]:
            if item[0] == key:
                item[1] = value
                return
        self.table[hashkey].append([key, value])

    def get(self, key: int) -> int:
        hashkey = self.hash(key)
        for item in self.table[hashkey]:
            if item[0] == key:
                return item[1]
        return -1

    def remove(self, key: int) -> None:
        hashkey = self.hash(key)
        for i, item in enumerate(self.table[hashkey]):
            if item[0] == key:
                self.table[hashkey].pop(i)
                return
```


**136. 只出现一次的数字**
题目描述：给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

```python
    class Solution:
        def singleNumber(self, nums: List[int]) -> int:
            #一、用字典统计元素个数
            # hash_map = Counter(nums)
            hash_map = {}
            
            #方法一
            for i in nums:
                hash_map[i] = hash_map.get(i, 0) + 1
                
            #方法二
            # for i in nums:
            #     if i not in hash_map:
            #         hash_map[i] = 1
            #     else:
            #         hash_map[i] += 1
            
            #二、找出只出现一次的元素
            
            #方法一
            return list(hash_map.keys())[list(hash_map.values()).index(1)]
        
            #方法二
            # new_hash_map = {v:k for k,v in hash_map.items()}
            # return new_hash_map[1]
        
            #方法三
            # return [key for key, value in hash_map.items() if value == 1]
            
            # 或
            # for key,value in hash_map.items():
            #     if value == 1:
            #         return key
```


**137. 只出现一次的数字 II**
题目描述：给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        hash_map = Counter(nums)
        return min(hash_map.items(), key=lambda x:x[1])[0]
```



**260. 只出现一次的数字 III**

题目描述：给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        hash_map = collections.Counter(nums)
        res = []
        for key, val in hash_map.items():
            if val == 1:
                res.append(key)
        return res
```



**217. 存在重复元素**

题目描述：给你一个整数数组 nums。如果任一值在数组中出现 至少两次，返回 true；如果数组中每个元素互不相同，返回 false。

**1. 哈希字典**

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hash_map = {}
        for num in nums:
            if num in hash_map:
                hash_map[num] += 1
            else:
                hash_map[num] = 1

        for index in hash_map:
            if hash_map[index] >= 2:
                return True
        return False
```

**2. 哈希集合**

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hash_set = set()
        for num in nums:
            if num in hash_set:
                return True
            else:
                hash_set.add(num)
        return False
```

**3. 集合的性质**

```python
class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        # return sum(nums) != sum(set(nums)) or nums.count(0) > 1
        return len(nums) != len(set(nums))
```

<img src ="https://img-blog.csdnimg.cn/d2a4a0debc284133b03fdd564b137ce7.gif#pic_center" width = 48%>

**219. 存在重复元素 II**

题目描述：给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 $abs(i - j) <= k$。如果存在，返回 true；否则，返回 false 。

```python
# 找到重复元素和其索引
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        hash_map = {}
        for i in range(len(nums)):
            # 已经存在重复的情况
            if nums[i] in hash_map and abs(i - hash_map[nums[i]]) <= k:
                return True
            else:
                hash_map[nums[i]] = i
        return False
```

```python
# 维护一个长度为 k 的集合
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        hash_set = set()
        for i in range(len(nums)):
            # 存在重复元素
            if nums[i] in hash_set:
                return True
            hash_set.add(nums[i])
            # 及时删除超出数组长度的元素
            if len(hash_set) > k:
                hash_set.remove(nums[i - k])
        return False
```



**220. 存在重复元素 III**
题目描述：给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 $abs(nums[i] - nums[j]) <= t$，同时又满足 $abs(i - j) <= k$。如果存在则返回 true，不存在返回 false。

```python
class Solution:
    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:
        bucket_dict = dict()
        for i in range(len(nums)):
            # 将nums[i]划分到大小为 t + 1 的不同桶中，分桶操作
            num = nums[i] // (t + 1)
            # print(num)

            # 如果桶中已经有元素，有相同的分桶结果，表示存在相同元素
            if num in bucket_dict:
                return True
            # 将 nums[i] 放入桶中
            bucket_dict[num] = nums[i]
            # print(bucket_dict)

            # 判断左侧桶是否满足条件
            if (num - 1) in bucket_dict and abs(bucket_dict[num - 1] - nums[i]) <= t:
                return True
            # 判断右侧桶是否满足条件
            if (num + 1) in bucket_dict and abs(bucket_dict[num + 1] - nums[i]) <= t:
                return True
            # 将 i - k 之前的旧桶清除，因为之前的桶已经不满足条件了
            if i >= k:
                bucket_dict.pop(nums[i-k] // (t + 1))  
        return False
```


**349. 两个数组的交集**

题目描述：给定两个数组 nums1 和 nums2，返回它们的交集。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序。

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        l1 = set(nums1)
        l2 = set(nums2)
        return list(l1 & l2)
```

```python
class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hash_map = dict()
        result = []
        for num1 in nums1:
            if num1 not in hash_map:
                hash_map[num1] = 1         # 只做一次计数
        for num2 in nums2:
            if num2 in hash_map and hash_map[num2] != 0:
                hash_map[num2] -= 1        # 及时对结果进行处理  
                result.append(num2)
        return result
```




**350. 两个数组的交集 II**

题目描述：给你两个整数数组 nums1 和 nums2，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

```python
class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        hash_map = {}
        result = []
        for num1 in nums1:
            if num1 in hash_map:
                hash_map[num1] += 1
            else:
                hash_map[num1] = 1

        for num2 in nums2:
            if num2 in hash_map and hash_map[num2] != 0:
                hash_map[num2] -= 1
                result.append(num2)
        return result
```




**36. 有效的数独**

请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次

```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        # 记录行数据、列数据、3x3格子数据，用于标记 1-9 共10个数字
        rows = [[0 for _ in range(10)] for _ in range(10)]
        columns = [[0 for _ in range(10)] for _ in range(10)]
        boxes = [[0 for _ in range(10)] for _ in range(10)]

        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    # 1-9数字是否重复出现
                    num = int(board[i][j])
                    board_index = (i // 3) * 3 + j // 3  # 方格角标的计算用 box[(i/3)*3+(j/3)][n] 来表示
                    if rows[i][num] > 0 or columns[j][num] > 0 or boxes[board_index][num] > 0:
                        return False
                    rows[i][num] = 1
                    columns[j][num] = 1
                    boxes[board_index][num] = 1
        return True
```

**389. 找不同**

题目描述：给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。

**1. 哈希字典**
```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return list(Counter(t) - Counter(s))[0]
```

**2. 异或运算**

```python
class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        return chr(reduce(xor, map(ord, s + t)))
```


**496. 下一个更大元素 I**





**26. 删除排序数组中的重复项**




**287. 寻找重复数**




____


## 参考
- 哈希表：[https://www.programmercarl.com/哈希表理论基础.html#哈希表](https://www.programmercarl.com/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%93%88%E5%B8%8C%E8%A1%A8)
- 