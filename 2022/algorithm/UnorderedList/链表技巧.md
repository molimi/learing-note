这一部分的内容，前面的大佬总结的挺多，这里进行汇总，方便和大家一起学习和回顾。

## 1 链表和数组

作为线性表的两种存储方式————链表和数组，这对相爱相杀的好基友有着各自的优缺点。接下来，我们梳理一下这两种方式。

数组，所有元素都连续的存储于一段内存中，且每个元素占用的内存大小相同。这使得数组具备了通过下标快速访问数据的能力。

但连续存储的缺点也很明显，增加容量，增删元素的成本很高，时间复杂度均为 $O(n)$。
增加数组容量需要先申请一块新的内存，然后复制原有的元素。如果需要的话，可能还要删除原先的内存。

<img src ="https://img-blog.csdnimg.cn/d6bc631f722c41478a9f253652a295cd.gif#pic_center" width = 48%>

删除元素时需要移动被删除元素之后的所有元素以保证所有元素是连续的。增加元素时需要移动指定位置及之后的所有元素，然后将新增元素插入到指定位置，如果容量不足的话还需要先进行扩容操作。

<img src ="https://img-blog.csdnimg.cn/dd25561f02c943ca9f67c31e864d1f85.gif#pic_center" width = 48%>

总结一下数组的优缺点：
- 优点：可以根据偏移实现快速的随机读写。
- 缺点：扩容，增删元素极慢。

上面对数组增删元素的操作表明使用数组需要注意的东西真的很多很多，这样一来，我们就开始说说链表，链表也是一种数据结构，它弥补了数组带来的诸多不便，让我们可以任意为一些数据进行空间的分配，根据需要进行内存单元的开辟。


链表是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，由若干个结点组成，在每一个结点里存到下一个结点的指针(Next)。采用动态分配存储单元方式。它能够有效地节省存储空间（同数组比较）。结点结构如下图所示：

<img src ="https://img-blog.csdnimg.cn/30018086251544649ed594ac7aab612e.png#pic_center" width = 48%>

一般来讲，链表中只会有一个结点的指针域为空，该结点为尾结点，其他结点的指针域都会存储一个结点的内存地址。链表中也只会有一个结点的内存地址没有存储在其他结点的指针域，该结点称为头结点。

<img src ="https://img-blog.csdnimg.cn/1ee578a325f1437a9214c6e1b61722b7.png#pic_center" width = 48%>


小结：从本质上来讲，链表与数组的确有相似之处，他们的相同点是都是线性数据结构，这与树和图不同，而它们的不同之处在于数组是一块连续的内存，而链表可以不是连续内存，链表的节点与节点之间通过指针来联系。

对于链表而言，分为静态链表和动态链表，根据处理数据的方向又分为单向链表和双向链表。对于链表的更多操作，请阅读[Python数据结构与算法篇（四）-- 链表的实现](https://blog.csdn.net/xq151750111/article/details/129130524?spm=1001.2014.3001.5501)

## 2 常见链表问题解决思路
### 2.1 单链表的反转

**方法一：头插法（迭代法）**
算法思想：逆置链表初始为空，表中节点从原链表中依次“删除”，再逐个插入逆置链表的表头（即“头插”到逆置链表中），使它成为逆置链表的“新”的第一个结点，如此循环，直至原链表为空。

**方法二：递归法：**
算法思想：从后向前改变指向，可以理解成向后的箭头变成了向前的箭头

**方法三：三指针法**
算法思想：从前向后改变指向，可以理解成向后的箭头变成了向前的箭头

### 2.2 单链表的删除某一节点
**方法一：遍历**
思路：查找到所要删除的节点，以及其前驱节点，让其前驱节点，指向其后继节点

**方法二：置换法（移花接木）**
思路：明确要删除的节点后，把其后继节点复制到该节点上，然后删除那个后继节点，也等于变相的删除节点（注意如果删除的是尾节点 删除的链表只有一个节点）


### 2.3 在当前节点前插入一个数据x
**方法一：遍历**
思路：找出当前结点的前驱节点，完成插入；

**方法二：置换法**
思路：把插入节点的数据放到新节点上，把新节点的数据放到插入节点的数据上，这样我们就可以实现在当前节点前插入一个节点了。

### 2.4 查找链表的中间结点
**快慢指针法**
思路：给一个快指针，让快指针每次移动两步，给一个慢指针，让慢指针每次移动一步，最后结果就是快指针移动到最后一个节点，慢指针最后移动到了中间的节点上。

设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast 向后走两次，slow 向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 恰好指向中间两个结点的靠前一个。

<img src ="https://img-blog.csdnimg.cn/d2f018f2fe42439f81fb13e6edb02ae6.png#pic_center" width = 48%>


### 2.5 单链表的倒数第k个结点

**方法一：正数转换法**
思路：遍历一遍单链表，记录单链表的长度，倒数第k个，即正数length-k+1个，在重头遍历一次便能够找到
**方法二：快慢指针法**
思路：一个指针先走k步，然后两个指针同时走，当先走的那个指针指向空的时候，后面的指针所指即为倒数第K个节点。

设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1 个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。可以参考下图来理解：

<img src ="https://img-blog.csdnimg.cn/75e7ca3d17164738bc5763b489f2e813.png#pic_center" width = 48%>


### 2.6 对称单链表

**1. 知道链表的长度**
思路：根据对称来确定两个指针的位置，对所指向的元素进行判断，不断前进指针

**2. 链表长度未知**
思路1：将前一半的节点压入栈中，并将当前节点继续遍历，每遍历一个都与栈弹出的节点相比较，若不同则不是。
额外空间复杂度 O(N/2)。
思路2：不使用辅助空间 两个指针，一个指向头first，指向头的后继节点last；first走一步，last走两步；直到last为空或last的后继节点为空，此时first指向（链表长度为基数，指向中间；为偶数，指向一半）；然后fisrt向后走，在申请一个节点指向头，不断进行比较，直到first指向空。

### 2.7 单链表是否有环

**方法一：map表法**
算法思想：每走一步将走过的节点使用map表存储起来，当遇到第一个在map中存在的节点时，就说明回到了出发点，即链表有环，同时也找到了环的入口。

**方法二：快慢指针法**
算法思想：一个指针走两步；一个指针走一步；如果存在环，两个指针最终会指向同一个元素；如果不存在环，走两步的会最终走向空节点。

当一个链表有环时，快慢指针都会陷入环中进行无限次移动，然后变成了追及问题。想象一下在操场跑步的场景，只要一直跑下去，快的总会追上慢的。当两个指针都进入环后，每轮移动使得慢指针到快指针的距离增加一，同时快指针到慢指针的距离也减少一，只要一直移动下去，快指针总会追上慢指针。

<img src ="https://img-blog.csdnimg.cn/ef9645e39f47436094f757c674d73b22.gif#pic_center" width = 36%>



**确定有环后求环的长度**
<img src ="https://img-blog.csdnimg.cn/243914aa44c341ee97c5184ddbbbf321.png#pic_center" width = 48%>
 
通过公式的推导我们发现 $L=kc-n$（这里的 $k$ 是倍数，有可能快指针在环里转了 $k$ 圈），也就是说相遇节点到入环点的距离等于链表的头到入环点的距离。写代码的时候只需要找到相遇节点，再让一个指针从头开始走即可。

### 2.8 判断两个链表是否相交;相交则求交点(链表不带环)
思路：
若两个不带环的链表相交，则他们的尾节点必相同；若要求交点，则需要比较两个链表的长度，让较长的链表先向后遍历至和较短的链表长度相等，然后两个链表同时向后遍历，并比较节点是否相同，当遇到第一个相同的节点时，则为两个链表的交点。

### 2.9 判断两个链表是否相交,若相交则求交点(链表可能带环)
情况分析：
若有两个链表，则他们的带环情况有以下三种可能：
（1）两个链表都不带环
直接采用上述思路即可；
（2）一个链表带环一个链表不带环
必定不想交；
（3）两个链表都带环
下面详细讨论：

<img src ="https://img-blog.csdnimg.cn/9f218c1b025347b7bc904d18123f77a2.png#pic_center" width = 48%>

- 当出现①情况时，两个链表不相交。
- 当出现②情况时，两个链表的交点在环外，那么我们可以转化为不带环链表判断相交即可。
- 当出现③情况时，两个链表的交点在环内，那么我们可以遍历其中一个链表的环，若在环内与另一个链表环的入口点相交，则两个链表相交，相遇点即为两个链表的交点。
- 要判断为情况②还是情况③，只需判断两个链表环的入口点是否相同即可。

## 3 LeetCode

<img src ="https://img-blog.csdnimg.cn/37cbd94278674319a3c257d899f7d63f.png#pic_center" width = 96%>

### 3.1 删除链表结点


**题库列表：**
<blockquote> 
 <p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank">237. 删除链表中的节点</a> ====<a href="https://leetcode-cn.com/problems/delete-middle-node-lcci/" target="_blank">面试题 02.03. 删除中间节点</a></p> 
 <p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank">203. 移除链表元素</a>（虚拟头结点）</p> 
 <ul><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank">83. 删除排序链表中的重复元素</a></li><li><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/" target="_blank">剑指 Offer 18. 删除链表的节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci/" target="_blank">面试题 02.01. 移除重复节点</a></li><li><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank">82. 删除排序链表中的重复元素 II</a></li></ul> 
 <p><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank">19. 删除链表的倒数第 N 个结点</a>（双指针经典类型）</p> 
 <ul><li><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/" target="_blank">876. 链表的中间结点</a></li><li><a href="https://leetcode-cn.com/problems/partition-list/" target="_blank">86. 分隔链表</a></li><li><a href="https://leetcode-cn.com/problems/odd-even-linked-list/" target="_blank">328. 奇偶链表</a></li></ul> 
</blockquote>



### 3.2 反转链表节点

**题库列表：**
<blockquote> 
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank">206. 反转链表</a>====<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/" target="_blank">剑指 Offer 24. 反转链表</a></p>
<p><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank">92. 反转链表 II</a></p>
<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank">234. 回文链表</a>====<a href="https://leetcode-cn.com/problems/palindrome-linked-list-lcci/" target="_blank">面试题 02.06. 回文链表</a></p>
<p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank">25. K 个一组翻转链表</a></p>
</blockquote> 

### 3.3  合并链表
题库列表：
<blockquote> 
<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank">147. 对链表进行插入排序</a></p>
<p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank">148. 排序链表</a></p>
</blockquote> 



### 3.4 排序链表

题库列表：
<blockquote> 
<p><a href="https://leetcode-cn.com/problems/insertion-sort-list/" target="_blank">147. 对链表进行插入排序</a></p>
<p><a href="https://leetcode-cn.com/problems/sort-list/" target="_blank">148. 排序链表</a></p>
</blockquote> 


### 3.5 环形链表

题库列表：
<blockquote> 
<ul><li> <p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank">160. 相交链表</a></p> </li><li> <p><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank">141. 环形链表</a></p> 
<ul><li><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank">142. 环形链表 II</a></li></ul> </li></ul>
</blockquote> 



## 参考
- 一文搞定常见的链表问题：[https://leetcode.cn/problems/linked-list-cycle/](https://leetcode.cn/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/)
- 链表常见问题解决思路：[https://blog.csdn.net/weixin_43910851/article/details/105725577](https://blog.csdn.net/weixin_43910851/article/details/105725577)
- [https://blog.csdn.net/qq_42647903/article/details/120594925](https://blog.csdn.net/qq_42647903/article/details/120594925)
- 一文通数据结构与算法之——链表+常见题型与解题策略+Leetcode经典题：[https://blog.csdn.net/qq_42647903/article/details/120594925](https://blog.csdn.net/qq_42647903/article/details/120594925)
- 两个技巧搞定常见面试链表题：[https://blog.csdn.net/weixin_45750855/article/details/](https://blog.csdn.net/weixin_45750855/article/details/120065894#:~:text=%E4%B8%A4%E4%B8%AA%E6%8A%80%E5%B7%A7%E6%90%9E%E5%AE%9A%E5%8A%9B%E6%89%A3%E5%B8%B8%E8%A7%81%20%E9%93%BE%E8%A1%A8%20%E9%A2%98%201%201.%20%E6%8E%8C%E6%8F%A1%E5%93%91%E8%8A%82%E7%82%B9%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7%E5%AF%BC%E8%87%B4%E5%9C%A8%E6%88%91%E4%BB%AC%E5%AF%B9%E5%A4%B4%E7%BB%93%E7%82%B9%E6%89%A7%E8%A1%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E6%97%B6%EF%BC%8C%20%E9%9C%80%E8%A6%81%E5%A4%84%E7%90%86%E5%A4%B4%E8%8A%82%E7%82%B9%E4%B8%BA%E7%A9%BA%E7%9A%84%E8%BE%B9%E7%95%8C%E9%97%AE%E9%A2%98%E3%80%82,%E5%92%8C%20slow%EF%BC%8C%E5%88%9D%E5%A7%8B%E6%97%B6%E5%9D%87%E6%8C%87%E5%90%91%E5%A4%B4%E7%BB%93%E7%82%B9%E3%80%82%20%E9%A6%96%E5%85%88%EF%BC%8C%E5%85%88%E8%AE%A9%20fast%20%E7%A7%BB%E5%8A%A8%20k%20%E6%AC%A1%E3%80%82%20)
- 算法面试题 | 链表问题总结：[https://juejin.cn/post/6882370280946302983](https://juejin.cn/post/6882370280946302983)











本次博客整理自大佬 Time-Limit——[相爱相杀好基友——数组与链表](https://leetcode.cn/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/)
