# 1 链接表

实现线性表的另一种常用方式就是基于链接结构，用链接关系显式表示元素之间的顺序关联。基于链接技术实现的线性表称为链接表或者链表。

采用链接方式实现线性表的基本想法如下:
- 把表中的元素分别存储在一批独立的存储块(称为表的结点）里。
- 保证从组成表结构中的任一个结点可找到与其相关的下一个结点。
- 在前一结点里用链接的方式显式地记录与下一结点之间的关联。

这样，只要能找到组成一个表结构的第一个结点，就能顺序找到属于这个表的其他结点。从这些结点里可以看到这个表中的所有元素。


链接技术是一类非常灵活的数据组织技术，实现链表有多种不同的方式。下面首先讨论最简单的单链表，其中在每个表结点里记录着存储下一个表元素的结点的标识(引用/链接)。后面将介绍另外一些结构的链表，它们各有所长，支持不同的需要。在下面的讨论中，将把“存储着下一个表元素的结点”简称为“下一结点”。

## 1.1 单链表

单向链接表（下面将简称为单链表或者链表）的结点是一个二元组，形式如下图a所示，其表元素域 elem 保存着作为表元素的数据项（或者数据项的关联信息），链接域 next 里保存同一个表里的下一个结点的标识。

<img src ="https://img-blog.csdnimg.cn/b5bf99173a614fe3837056a47ccad6e9.png#pic_center" width = 36%>

在最常见形式的单链表里，与表里的n个元素对应的n个结点通过链接形成─条结点链，如上图b所示。从引用表中首结点的变量（上图b中变量p）可以找到这个表的首结点，从表中任一结点可以找到保存着该表下一个元素的结点（表中下一结点），这样，从p出发就能找到这个表里的任一个结点。

要想掌握一个单链表，就需要（也只需要）掌握这个表的首结点，从它出发可以找到这个表里的第一个元素（即在这个表结点里保存的数据，保存在它的 elem域中），还可以找到这个表里的下一结点（有关信息保存在这个结点的 next 域中）。按照同样的方式继续下去，就可以找到表里的所有数据元素。

也就是说，为了掌握一个表，只需要用一个变量保存着这个表的首结点的引用（标识或称为链接）。今后将把这样的变量称为表头变量或表头指针。

小结一下:
- —个单链表由一些具体的表结点构成。
- 每个结点是一个对象，有自己的标识，下面也常称其为该结点的链接。
- 结点之间通过结点链接建立起单向的顺序联系。


为了表示一个链表的结束，只需给表的最后结点（表尾结点）的链接域设置一个不会作为结点对象标识的值（称为空链接），在 Python 里自然可以用系统常量 None 表示这种情况，在上图里用接地符号“丄”表示链表结束，下面将一直这样表示。

通过判断一个（域或变量的）值是否为空链接，可知是否已到链表的结束。在顺序扫描表结点时，应该用这种方法确定操作是否完成。如果一个表头指针的值是空链接，就说明“它所引用的链表已经结束”，这是没有元素就已结束，说明该表是空表。

在实现链表上的算法时，并不需要关心在某个具体的表里各结点的具体链接值是什么（虽然保存在表结构里的值都是具体的），只需要关心链表的逻辑结构。对链表的操作也只需要根据链表的逻辑结构考虑和实现。

为方便下面的讨论，现在定义个简单的表结点类:

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val    
        self.next = next
```

### 1.2 基本链表操作

**创建空链表：** 只需要把相应的表头变量设置为空链接，在Python语言中将其设置为None，在其他语言里也有惯用值，例如有的语言里用0作为这个特殊值。

**删除链表：** 应丢弃这个链表里的所有结点。这个操作的实现与具体的语言环境有关。在一些语言（如C语言）里，需要通过明确的操作释放一个个结点所用的存储。在Python语言中这个操作很简单，只需简单地将表指针赋值为None，就抛弃了链表原有的所有结点。Python解释器的存储管理系统会自动回收不用的存储。

**判断表是否为空：** 将表头变量的值与空链接比较。在Python语言中，就是检查相应变量的值是否为None.

**判断表是否满：** 一般而言链表不会满，除非程序用完了所有可用的存储空间。

**加入元素**

现在考虑给单链表加入元素的操作，同样有插入位置问题，可以做首端插入、尾端插人或者定位插人。不同位置的操作复杂度可能不同。

首先应该注意，在链表里加入新元素时，并不需要移动已有的数据，只需为新元素安排一个新结点，然后根据操作要求，把新结点连在表中的正确位置。也就是说，插入新元素的操作是通过修改链接，接入新结点，从而改变表结构的方式实现的。

**表首端插入：** 首端插入元素要求把新数据元素插入表中，作为表的第一个元素，这是最简单的情况。这一操作需要通过三步完成：

1) 创建一个新结点并存入数据（下图a表示要向表头变量 head 的链表加入新首元素13，为它创建了新结点，变量q指着该结点。这是实际插入前的状态）。

<img src ="https://img-blog.csdnimg.cn/832f83d57f004a5880d99b0bee5fe1de.png#pic_center" width = 36%>


2) 把原链表首结点的链接存入新结点的链接域 next，这一操作将原表的一串结点链接在刚创建的新结点之后。
   
3) 修改表头变量，使之指向新结点，这个操作使新结点实际成为表头变量所指的结点，即表的首结点（上图b表示设置链接的这两步操作完成后的状态，新结点已成为 head 所指链表的首结点，13成为这个表的首元素。注意，示意图中链接指针的长度和形状都不表示任何意义，只有图中的链接指向关系有意义）。

注意，即使在插入前head指向的是空表，上面三步也能正确完成工作。这个插人只是一次安排新存储和几次赋值，操作具有常量时间复杂度。

示例代码段：
```python
q = ListNode(13)
q.next = head.next
head = q
```

**一般情况的元素插入：**要想在单链表里的某位置插入一个新结点，必须先找到该位置之前的那个结点，因为新结点需要插入在它的后面，需要修改它的next 域。如何找到这个结点的问题将在后面讨论，先看已经找到了这个结点之后怎样插入元素。

设变量pre已指向要插入元素位置的前一结点，操作也分为三步:
1) 创建一个新结点并存入数据（下图a是实际插入前的状态）。
2) 把 pre 所指结点 next 域的值存入新结点的链接域 next，这个操作将原表在 pre 所指结点之后的一段链接到新结点之后。
3) 修改 pre 的 next 域，使之指向新结点，这个操作把新结点链入被操作的表，整个操作完成后的状态如下图b所示。

<img src ="https://img-blog.csdnimg.cn/8fc59b745aed4e0d87cd7b040f18d537.png#pic_center" width = 48%>

注意，即使在插入前 pre 所指结点是表中最后一个结点，上述操作也能将新结点正确接入，作为新的表尾结点。
```python
q = ListNode(13)
q.next = pre.next
pre.next = q
```

**删除元素**

删除链表中元素，也可通过调整表结构删除表中结点的方式完成。这里也区分两种情况：删除表头结点的操作可以直接完成，删除其他结点也需要掌握其前一结点。
**删除表首元素：** 删除表中第一个元素对应于删除表的第一个结点，为此只需修改表头指针，令其指向表中第二个结点。丢弃不用的结点将被Python解释器自动回收。
```python
head = head.next
```
一般情况的元素删除：一般情况删除须先找到要删元素所在结点的前一结点，设用变量pre指向，然后修改pre的next域，使之指向被删结点的下一结点。

```python
pre.next = pre.next.next
```
显然，这两个操作都要求被删结点存在。

<img src ="https://img-blog.csdnimg.cn/a8bdc83b11094d04a21048c48de189b4.png#pic_center" width = 48%>

如果在其他编程语言里删除结点，还可能要自己释放存储。Python的自动存储管理机制能自动处理这方面的问题，使编程工作更简单，也保证了安全性。

**扫描、定位和遍历**

在一般情况下插入和删除元素，都要求找到被删结点的前一结点。另外，程序里也可能需要定位链表中的元素、修改元素、逐个处理其中元素等。这些操作都需要检查链表的内容，实际上是检查表中的一些（或全部）结点。

由于单链表只有一个方向的链接，开始情况下只有表头变量在掌握中，所以对表内容的一切检查都只能从表头变量开始，沿着表中链接逐步进行。这种操作过程称为链表的扫描，这种过程的基本操作模式是:

```python
p = head
while p is not None and 还需继续的其他条件:
    对p所指结点里的数据做所需操作
    p = p.next
```

循环的继续（或结束）条件、循环中的操作由具体问题决定。循环中使用的辅助变量p称为扫描指针。注意，每个扫描循环必须用一个扫描指针作为控制变量，每步迭代前必须检查其值是否为None，保证随后操作的合法性。这与连续表的越界检查类似。

上面表扫描模式是最一般的链表操作模式，下面介绍几个常用操作的实现。

**按下标定位：** 按 Python 惯例，链表首结点的元素应看作下标0，其他元素依次排列。确定第i个元素所在结点的操作称为按下标定位，可以参考表扫描模式写出:
```python
p = head
while p is not NOne and i > 0:
    i -= 1
    p = p.next
```

假设循环前变量i已有所需的值，循环结束时可能出现两种情况：或者扫描完表中所有结点还没有找到第i个结点，或者p所指结点就是所需。通过检查 p 值是否为None可以区分这两种情况。显然，如果现在需要删除第k个结点，可以先将i设置为k-1，循环后检查i是0且p.next不是None就可以执行删除了。

**按元素定位：** 假设需要在链表里找到满足谓词pred的元素。同样可以参考上面的表扫描模式，写出的检索循环如下:

```python
p = head
while p is not None and not pred(p.val):
    p = p.next
```
循环结束时或者p是None；或者pred (p.val)是 True，找到了所需元素。

完整的扫描称为遍历，这样做通常是需要对表中每个元素做一些事情，例如:
```python
p = head
while p is not None:
    print(p.val)
    p = p.next
```
这个循环依次输出表中各元素。只以条件 `p is not None` 控制循环，就能完成一遍完整的遍历。同样模式可用于做其他工作。

链表操作的复杂度
总结一下链表操作的时间复杂度。
- 创建空表：$O(1)$。
- 删除表：在Python里是$O(1)$。当然，Python 解释器做存储管理也需要时间。
- 判断空表：$O(1)$。
- 加入元素（都需要加一个T(分配)的时间）
  - 首端加入元素：$O(1)$。
  - 尾端加入元素：$O(n)$、因为需要找到表的最后结点。
  - 定位加人元素：$O(n)$，平均情况和最坏情况。

- 删除元素:
  - 首端删除元素：$O(1)$。
  - 尾端删除元素：$O(n)$。
  - 定位删除元素：$O(n)$，平均情况和最坏情况。
  - 其他册除：通常需要扫描整个表或其一部分$O(n)$。

扫描、定位或遍历操作都需要检查一批表结点，其复杂度受到表结点数的约束，都是 $O(n)$ 操作。其他在工作中有此类行为的操作也至少具有 $O(n)$ 时间复杂度。

求表的长度

在使用链表时，经常需要求表的长度，为此可以定义一个函数:
```python
p, n = head, 0
while p is not None:
    n += 1
    p = p.next
return n
```

这个函数采用表扫描模式，遍历表中所有结点完成计数。
显然，这个求表长度的算法所用时间与表结点个数成正比，具有 $O(n)$ 时间复杂度。

实现方式的变化

以求表的长度为例，如果程序经常需要调用上面函数，$O(n)$ 复杂度就可能成为效率问题。如果表很长，执行该函数就可能造成可察觉的停顿。解决这个问题的一种方法是改造单链表的实现结构，增加一个表长度记录。显然，这个记录不属于任何表元素，是有关表的整体的信息。表示这件事的恰当方法是定义一种链表对象，把表的长度和表中的结点链表都作为这个表对象的数据成分，如下图所示。

<img src ="https://img-blog.csdnimg.cn/5bb8b0da6beb414b82889c8003ee39f1.png#pic_center" width = 48%>

图中变星p指向表对象，这个对象的一个数据域记录表中元素个数（图中的20表示这个表当时有20个结点），另一个域引用着该表的结点链。采用了这种表示方式，求表长度的操作就可以简单返回元素计数域的值。但另一方面，这种表的每个变动操作都需要维护计数值。从整体看有得有失。这种调整消除了一个线性时间操作，可能在一些应用中很有意义。

### 1.3 单链表类的实现











在整个基本数据结构的讨论中，我们使用了Python列表来实现抽象数据类型。列表是一个功能强大而简单的收集容器，并为程序员提供了各种各样的操作。然而，并非所有的编程语言都有内置的list列表类型。在这些情况下，程序员必须自己来实现列表。

无序列表结构是一个由各个元素组成的集合，在其中的每个元素拥有一个不
同于其它元素的相对位置。一些可用的无序列表的方法如下。无序表List的操作如下：

```python
List()：创建一个空列表
add(item)：添加一个数据项到列表中，假设item原先不存在于列表中
remove(item)：从列表中移除item，列表被修改，item原先应存在于表中
search(item)：在列表中查找item，返回布尔类型值
isEmpty()：返回列表是否为空
size()：返回列表包含了多少数据项
append(item)：添加一个数据项到表末尾，假设item原先不存在于列表中
index(item)：返回数据项在表中的位置
insert(pos, item)：将数据项插入到位置pos，假设item原先不存在与列表中，同时原列表具
有足够多个数据项，能让item占据位置pos
pop()：从列表末尾移除数据项，假设原列表至少有1个数据项
pop(pos)：移除位置为pos的数据项，假设原列表存在位置pos
```

为了实现无序表数据结构，可以采用链接表的方案。

数据项存放位置并没有规则，但如果在数据项之间建立链接指向，就可以保持其前后相对位置


## 1 无序链表 UNORDEREDLIST
### 1.1 节点 NODE
链表实现的最基本元素是节点Node，每个节点至少要包含2个信息：数据项本身，以及指向下一个节点的引用信息
注意next为None的意义是没有下一个节点了，这个很重要


```python
class Node:
    def __init__(self, init_data):
        self.data = init_data
        self.next = None
    
    def get_data(self):
        return self.data
    
    def get_next(self):
        return self.next
    
    def set_data(self, new_data):
        self.data = new_data

    def set_next(self, new_next):
        self.next = new_next
```
可以采用链接节点的方式构建数据集来实现无序表
链表的第一个和最后一个节点最重要
如果想访问到链表中的所有节点，就必须从第一个节点开始沿着链接遍历下去


### 1.2 无序链表 



## 2 有序链表 ORDEREDLIST