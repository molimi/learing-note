递归是一种解决问题的方法，其精髓在于将问题分解为规模更小的相同问题，持续分解，直到问题规模小到可以用非常简单直接的方式来解决。

递归的问题分解方式非常独特，其算法方面的明显特征就是：在算法流程中调用自身。

下面举个例子：给定一个列表，返回所有数的和，列表中数的个数不定，需要一个循环和一个累加变量来迭代求和

```python
def list_sum1(num_list):
    sum = 0
    for item in num_list:
        sum += item
    return sum
```

那此时不用循环语句，怎么实现呢？求和实际上最终是由一次次的加法实现的，而加法恰有2个操作数，这个是确定的。那如何将问题规模较大的列表求和，分解为规模较小而且固定的2个数求和（加法）？


换个方式来表达数列求和：全括号表达式 (1+(3+(5+(7+9))))，最内层的括号(7+9)，这是无需循环即可计算的，实际上整个求和的过程是这样：

$$
\begin{aligned}
& \text { total }=(1+(3+(5+(7+9)))) \\
& \text { total }=(1+(3+(5+16))) \\
& \text { total }=(1+(3+21)) \\
& \text { total }=(1+24) \\
& \operatorname{total}=25 \\
&
\end{aligned}
$$

观察上述过程中所包含的重复模式，可以把求和问题归纳成这样：数列的和=“首个数”+“余下数列”的和，如果数列包含的数少到只有1个的话，它的和就是这个数了。这是规模小到可以做最简单的处理：

<img src ="https://img-blog.csdnimg.cn/15e9d9785133480fa0af99516d783b26.png#pic_center" width = 64%>


```python
def list_sum(num_list):
    if len(num_list) == 1: 
        return num_list[0]
    else: 
        return num_list[0] + list_sum(num_list[1:])
```

递归函数调用和返回过程的链条
<img src ="https://img-blog.csdnimg.cn/066d371289b94e39be7e1c43c07ecf01.png#pic_center" width = 64%>


递归算法也总结出“三定律”：
1. 递归算法必须有一个基本结束条件（最小规模问题的直接解决）
2. 递归算法必须能改变状态向基本结束条件演进（减小问题规模）
3. 递归算法必须调用自身（解决减小了规模的相同问题）





## 参考
- 为什么你学不会递归？谈谈我的经验：[https://juejin.cn/post/7145888770410151967](https://juejin.cn/post/7145888770410151967)