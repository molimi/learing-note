## 1 二分法介绍
### 1.1 定义

二分查找又称折半查找、二分搜索、折半搜索等，是一种在静态查找表中查找特定元素的算法。

> 所谓静态查找表，即只能对表内的元素做查找和读取操作，不允许插入或删除元素。

使用二分查找算法，必须保证查找表中存放的是有序序列（升序或者降序）。换句话说，存储无序序列的静态查找表，除非先对数据进行排序，否则不能使用二分查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。下图对比了顺序查找和二分查找的不同：

<img src ="https://img-blog.csdnimg.cn/965b2e1e284c4ff4babeb35e664c69e3.gif#pic_center" width = 48%>


二分查找的最基本问题是在有序数组里查找一个特定的元素，还可以应用在：
1. 在半有序（旋转有序或者是山脉）数组里查找元素；
2. 确定一个有范围的整数；
3. 需要查找的目标元素满足某个特定的性质。


二分查找算法的时间复杂度可以用  $O(log_2n)$ 表示（$n$ 为查找表中的元素数量，底数 2 可以省略）。和顺序查找算法的 $O(n)$ 相比，显然二分查找算法的效率更高，且查找表中的元素越多，二分查找算法效率高的优势就越明显。

###  1.2 二分法的三种写法

**1. 模板一**

```python
class Solution(object):

    def search(self, nums: List[int], target: int) -> int:
        # 特殊用例判断
        n = len(nums)
        if n == 0:
            return -1
        # 在 [left, right] 区间里查找target
        left, right = 0, n - 1
        while left <= right:
            # 为了防止 left + right 整形溢出，写成如下形式
            # Python 使用 BigInteger，所以不用担心溢出，但还是推荐使用如下方式
            mid = left + (right - left) // 2

            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                # 下一轮搜索区间：[left, mid - 1]
                right = mid - 1
            else:
                # 此时：nums[mid] < target
                # 下一轮搜索区间：[mid + 1, right]
                left = mid + 1
        return -1
```

注意事项：
- 许多刚刚写的朋友，经常在写 `left = mid + 1`；还是写 `right = mid - 1`; 感到困惑，一个行之有效的思考策略是：永远去想下一轮目标元素应该在哪个区间里：
    - 如果目标元素在区间 `[left, mid - 1]` 里，就需要设置设置 `right = mid - 1`；
    - 如果目标元素在区间 `[mid + 1, right]` 里，就需要设置设置 `left = mid + 1`；

考虑不仔细是初学二分法容易出错的地方，这里切忌跳步，需要仔细想清楚每一行代码的含义。
- 二分查找算法是典型的「减治思想」的应用，我们使用二分查找将待搜索的区间逐渐缩小，以达到「缩减问题规模」的目的；
- 循环可以继续的条件是 `while (left <= right)`，特别地，当 `left == right` 即当待搜索区间里只有一个元素的时候，查找也必须进行下去；
- `mid = (left + right) // 2`；在 `left + right` 整形溢出的时候，mid 会变成负数，回避这个问题的办法是写成 `mid = left + (right - left) // 2`;。

**2. 模板二**

版本一：
```python
def search(nums: List[int], left: int, right: int, target: int) -> int:
    while left < right:
        # 选择中位数时下取整
        mid = left + (right - left) // 2
        if check(mid):
            # 下一轮搜索区间是 [mid + 1, right]
            left = mid + 1
        else:
            # 下一轮搜索区间是 [left, mid]
            right = mid
    # 退出循环的时候，程序只剩下一个元素没有看到。
    # 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意
```

版本二：
```python
def search(nums: List[int], left: int, right: int, target: int) -> int:
    while left < right:
        # 选择中位数时上取整
        mid = left + (right - left + 1) // 2
        if check(mid):
            # 下一轮搜索区间是 [left, mid - 1]
            right = mid - 1
        else:
            # 下一轮搜索区间是 [mid, right]
            left = mid
    # 退出循环的时候，程序只剩下一个元素没有看到。
    # 视情况，是否需要单独判断 left（或者 right）这个下标的元素是否符合题意
```

理解模板代码的要点：
- 核心思想：虽然模板有两个，但是核心思想只有一个，那就是：把待搜索的目标元素放在最后判断，每一次循环排除掉不存在目标元素的区间，目的依然是确定下一轮搜索的区间；
- 特征：`while (left < right):`，这里使用严格小于 `<` 表示的临界条件是：当区间里的元素只有 2 个时，依然可以执行循环体。换句话说，退出循环的时候一定有 `left == right`成立，这一点在定位元素下标的时候极其有用；
- 在循环体中，先考虑 `nums[mid]` 在满足什么条件下不是目标元素，进而考虑两个区间 `[left, mid - 1]` 以及 `[mid + 1, right]` 里元素的性质，目的依然是确定下一轮搜索的区间； **注意 1：** 先考虑什么时候不是解，是一个经验，在绝大多数情况下不易出错，重点还是确定下一轮搜索的区间，由于这一步不容易出错，它的反面（也就是 `else` 语句的部分），就不用去考虑对应的区间是什么，直接从上一个分支的反面区间得到，进而确定边界如何设置；
- 根据边界情况，看取中间数的时候是否需要上取整； **注意 2：** 这一步也依然是根据经验，建议先不要记住结论，在使用这个思想解决问题的过程中，去思考可能产生死循环的原因，进而理解什么时候需要在括号里加 1 ，什么时候不需要；
- 在退出循环以后，根据情况看是否需要对下标为 `left` 或者 `right` 的元素进行单独判断，这一步叫「后处理」。在有些问题中，排除掉所有不符合要求的元素以后，剩下的那 1 个元素就一定是目标元素。如果根据问题的场景，目标元素一定在搜索区间里，那么退出循环以后，可以直接返回 left（或者 right）。

以上是这两个模板写法的所有要点，并且是高度概括的。请读者一定先抓住这个模板的核心思想，在具体使用的过程中，不断地去体会这个模板使用的细节和好处。只要把中间最难理解的部分吃透，几乎所有的二分问题就都可以使用这个模板来解决，因为「减治思想」是通用的。好处在这一小节的开篇介绍过了，需要考虑的细节最少。

学习建议：一定需要多做练习，体会这（两）个模板的使用。

注意事项：
- 先写分支，再决定中间数是否上取整；
- 在使用多了以后，就很容易记住，只要看到 left = mid ，它对应的取中位数的取法一定是 `mid = left + (right - left + 1) // 2`。

**3. 模板三**

```python
def search(nums: List[int], left: int, right: int, target: int) -> int:
    while left + 1 < right:
        # 选择中位数时下取整
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid
        elif nums[mid] < target:
            left = mid
        else:
            right = mid

    if nums[left] == target:
        return left
    if nums[right] == target:
        return right
    return -1
```

- 这一版代码和模板二没有本质区别，一个显著的标志是：循环可以继续的条件是 `while (left + 1 < right):`，这说明在退出循环的时候，一定有 `left + 1 == right` 成立，也就是退出循环以后，区间有 2 个元素，即 `[left, right]`；
- 这种写法的优点是：不用理解上一个版本在分支出现 left = mid 的时候中间数上取整的行为；
- 缺点是显而易见的：
    - `while (left + 1 < right):` 写法相对于 `while (left < right):` 和 `while (left <= right):` 来说并不自然；
    - 由于退出循环以后，区间一定有两个元素，需要思考哪一个元素才是需要找的，即「后处理」一定要做，有些时候还会有先考虑 `left` 还是 `right` 的区别。

小结：
- 模板一：最好理解的版本，但是在刷题的过程中，需要处理一些边界的问题，一不小心容易出错；
- 模板二：强烈推荐掌握的版本，应先理解思想，再通过实际应用去体会这个模板的细节，熟练使用以后就会觉得非常自然；
- 模板三：可以认为是模板二的避免踩坑版本，只要深刻理解了模板二，模板三就不在话下。

实际应用中，选择最好理解的版本即可。

这里有一个提示：模板二考虑的细节最少，可以用于解决一些相对复杂的问题。缺点是：学习成本较高，初学的时候比较容易陷入死循环，建议大家通过多多使用，并且尝试 debug，找到死循环的原因，进而掌握。

## 2 常见题型

**题库列表**

<blockquote><ul>
<li><p><a href="https://leetcode.cn/problems/binary-search/" target="_blank">704. 二分查找</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank">35. 搜索插入位置</a> </p>
<li><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">34. 在排序数组中查找元素的第一个和最后一个位置</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank">33. 搜索旋转排序数组</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">74. 搜索二维矩阵</a></p></li>
<li><p><a href="https://leetcode.cn/problems/sqrtx/" target="_blank">69. x的平方根</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li>
</ul></blockquote> 


**704. 二分查找**
题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```python
# lower_bound 返回最小的满足 nums[i] >= target 的 i
# 如果数组为空，或者所有数都 < target，则返回 len(nums)
# 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

# 闭区间写法
def lower_bound(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1  # 闭区间 [left, right]
    while left <= right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right+1] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1      # 范围缩小到 [mid+1, right]
        else:
            right = mid - 1     # 范围缩小到 [left, mid-1]
    return left                 # 或者 right+1

# 左闭右开区间写法
def lower_bound2(nums: List[int], target: int) -> int:
    left, right = 0, len(nums)  # 左闭右开区间 [left, right)
    while left < right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # 范围缩小到 [mid+1, right)
        else:
            right = mid  # 范围缩小到 [left, mid)
    return left  # 或者 right

# 开区间写法
def lower_bound3(nums: List[int], target: int) -> int:
    left, right = -1, len(nums)  # 开区间 (left, right)
    while left + 1 < right:  # 区间不为空
        mid = (left + right) // 2
        # 循环不变量：
        # nums[left] < target
        # nums[right] >= target
        if nums[mid] < target:
            left = mid  # 范围缩小到 (mid, right)
        else:
            right = mid  # 范围缩小到 (left, mid)
    return right  # 或者 left+1

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        i = lower_bound(nums, target)  # 选择其中一种写法即可
        return i if i < len(nums) and nums[i] == target else -1
```

<img src ="https://img-blog.csdnimg.cn/a02277b2400d45348bba9a9d77d53130.gif#pic_center" width = 48%>

**35. 搜索插入位置**

题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left
```





**33. 搜索旋转排序数组**


题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 <= k < nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。

```python

```



**34. 在排序数组中查找元素的第一个和最后一个位置**

题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums or target not in nums:
            return [-1, -1]
        return [self.lower_bound(nums, target), self.upper_bound(nums, target)]

    def upper_bound(self, nums: List[int], target: int):    # 寻找上边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid -1
        return right


    def lower_bound(self, nums: List[int], target: int):    # 寻找下边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        return left
```




**69. x 的平方根**

题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。






**74. 搜索二维矩阵**
题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数


```python

```



<img src ="https://img-blog.csdnimg.cn/6cc3afd9b2f9418e8ad78780420a1129.png#pic_center" width = 64%>

______
### 参考

- 二分查找算法：[https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README](https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README)
- 二分算法：[https://oi-wiki.org/basic/binary/](https://oi-wiki.org/basic/binary/)
- 二分查找：[https://www.cnblogs.com/jasonbourne3/p/17141780.html](https://www.cnblogs.com/jasonbourne3/p/17141780.html)
- 算法与数据结构（七）：二分查找法总结：[https://blog.csdn.net/Dby_freedom/article/details/94332149](https://blog.csdn.net/Dby_freedom/article/details/94332149)
- 一文带你搞定二分查找及其多个变种：[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/)
- 二分查找（折半查找）算法详解：[http://data.biancheng.net/view/336.html](http://data.biancheng.net/view/336.html)