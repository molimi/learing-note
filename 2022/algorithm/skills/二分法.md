## 1 二分法介绍
### 1.1 定义

二分查找又称折半查找、二分搜索、折半搜索等，是一种在静态查找表中查找特定元素的算法。

> 所谓静态查找表，即只能对表内的元素做查找和读取操作，不允许插入或删除元素。

使用二分查找算法，必须保证查找表中存放的是有序序列（升序或者降序）。换句话说，存储无序序列的静态查找表，除非先对数据进行排序，否则不能使用二分查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。下图对比了顺序查找和二分查找的不同：

<img src ="https://img-blog.csdnimg.cn/965b2e1e284c4ff4babeb35e664c69e3.gif#pic_center" width = 48%>


二分查找的最基本问题是在有序数组里查找一个特定的元素，还可以应用在：
1. 在半有序（旋转有序或者是山脉）数组里查找元素；
2. 确定一个有范围的整数；
3. 需要查找的目标元素满足某个特定的性质。


二分查找算法的时间复杂度可以用  $O(log_2n)$ 表示（$n$ 为查找表中的元素数量，底数 2 可以省略）。和顺序查找算法的 $O(n)$ 相比，显然二分查找算法的效率更高，且查找表中的元素越多，二分查找算法效率高的优势就越明显。

###  1.2 二分法的三种写法
```python
# lower_bound 返回最小的满足 nums[i] >= target 的 i
# 如果数组为空，或者所有数都 < target，则返回 len(nums)
# 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]

# 闭区间写法
def lower_bound(nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1  # 闭区间 [left, right]
    while left <= right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right+1] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # 范围缩小到 [mid+1, right]
        else:
            right = mid - 1  # 范围缩小到 [left, mid-1]
    return left  # 或者 right+1

# 左闭右开区间写法
def lower_bound2(nums: List[int], target: int) -> int:
    left, right = 0, len(nums)  # 左闭右开区间 [left, right)
    while left < right:  # 区间不为空
        # 循环不变量：
        # nums[left-1] < target
        # nums[right] >= target
        mid = (left + right) // 2
        if nums[mid] < target:
            left = mid + 1  # 范围缩小到 [mid+1, right)
        else:
            right = mid  # 范围缩小到 [left, mid)
    return left  # 或者 right

# 开区间写法
def lower_bound3(nums: List[int], target: int) -> int:
    left, right = -1, len(nums)  # 开区间 (left, right)
    while left + 1 < right:      # 区间不为空
        mid = (left + right) // 2
        # 循环不变量：
        # nums[left] < target
        # nums[right] >= target
        if nums[mid] < target:
            left = mid  # 范围缩小到 (mid, right)
        else:
            right = mid  # 范围缩小到 (left, mid)
    return right  # 或者 left+1

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        i = lower_bound(nums, target)  # 选择其中一种写法即可
        return i if i < len(nums) and nums[i] == target else -1
```


## 2 常见题型

**题库列表**

<blockquote> 
<ul><li><p><a href="https://leetcode.cn/problems/search-insert-position/" target="_blank">35. 搜索插入位置</a> </p>
<li><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<li><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank">33. 搜索旋转排序数组</a></p></li>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">74. 搜索二维矩阵</a></p></li></ul>
<li><p><a href="https://leetcode.cn/problems/sqrtx/" target="_blank">69. x的平方根</a></p></li></ul>
<li><p><a href="https://leetcode.cn/problems/binary-search/" target="_blank">704. 二分查找</a></p></li></ul>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
<li><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
</blockquote> 


**704. 二分查找**
题目描述：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```python

```

<img src ="https://img-blog.csdnimg.cn/a02277b2400d45348bba9a9d77d53130.gif#pic_center" width = 48%>



**33. 搜索旋转排序数组**


题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 <= k < nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。

```python

```



**34. 在排序数组中查找元素的第一个和最后一个位置**

题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums or target not in nums:
            return [-1, -1]
        return [self.lower_bound(nums, target), self.upper_bound(nums, target)]

    def upper_bound(self, nums: List[int], target: int):    # 寻找上边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid -1
        return right


    def lower_bound(self, nums: List[int], target: int):    # 寻找下边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        return left
```


**35. 搜索插入位置**

题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left
```

**69. x 的平方根**

题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。






**74. 搜索二维矩阵**
题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数


```python

```



<img src ="https://img-blog.csdnimg.cn/6cc3afd9b2f9418e8ad78780420a1129.png#pic_center" width = 64%>

______
### 参考

- 二分查找算法：[https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README](https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README)
- 二分算法：[https://oi-wiki.org/basic/binary/](https://oi-wiki.org/basic/binary/)
- 二分查找：[https://www.cnblogs.com/jasonbourne3/p/17141780.html](https://www.cnblogs.com/jasonbourne3/p/17141780.html)
- 算法与数据结构（七）：二分查找法总结：[https://blog.csdn.net/Dby_freedom/article/details/94332149](https://blog.csdn.net/Dby_freedom/article/details/94332149)
- 一文带你搞定二分查找及其多个变种：[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/)
- 二分查找（折半查找）算法详解：[http://data.biancheng.net/view/336.html](http://data.biancheng.net/view/336.html)