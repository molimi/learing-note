## 1 二分法介绍

二分查找（Binary Search）算法，也叫折半查找算法。它针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。



## 2 常见题型

**题库列表**

<blockquote> 
<ul><li><p>35. <a href="https://leetcode.cn/problems/search-insert-position/" target="_blank">搜索插入位置</a> </p>
<li><p>34. <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank">在排序数组中查找元素的第一个和最后一个位置</a></p>
<li><p>33. <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank">搜索旋转排序数组</a></p></li>
<li><p>74. <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
<li><p>69. <a href="https://leetcode.cn/problems/sqrtx/" target="_blank">x的平方根</a></p></li></ul>
<li><p>74. <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
<li><p>74. <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
<li><p>74. <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank">搜索二维矩阵</a></p></li></ul>
</blockquote> 




**33. 搜索旋转排序数组**


题目描述：整数数组 nums 按升序排列，数组中的值 互不相同。在传递给函数之前，nums 在预先未知的某个下标 $k(0 <= k < nums.length)$ 上进行了旋转，使数组变为 $[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]$（下标从0开始计数）。例如，[0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1。

```python

```



**34. 在排序数组中查找元素的第一个和最后一个位置**

题目描述：给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums or target not in nums:
            return [-1, -1]
        return [self.lower_bound(nums, target), self.upper_bound(nums, target)]

    def upper_bound(self, nums: List[int], target: int):    # 寻找上边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] <= target:
                left = mid + 1
            else:
                right = mid -1
        return right


    def lower_bound(self, nums: List[int], target: int):    # 寻找下边界
        left, right = 0, len(nums)-1
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] >= target:
                right = mid - 1
            else:
                left = mid + 1
        return left
```


**35. 搜索插入位置**

题目描述：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        return left
```

**69. x 的平方根**

题目描述：给你一个非负整数 x ，计算并返回 x 的算术平方根。由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。






**74. 搜索二维矩阵**
题目描述：编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
- 每行中的整数从左到右按升序排列。
- 每行的第一个整数大于前一行的最后一个整数


```python

```



<img src ="https://img-blog.csdnimg.cn/6cc3afd9b2f9418e8ad78780420a1129.png#pic_center" width = 64%>

______
### 参考

- 二分查找算法：[https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README](https://ojeveryday.github.io/AlgoWiki/#/BinarySearch/README)
- 二分算法：[https://oi-wiki.org/basic/binary/](https://oi-wiki.org/basic/binary/)
- 二分查找：[https://www.cnblogs.com/jasonbourne3/p/17141780.html](https://www.cnblogs.com/jasonbourne3/p/17141780.html)
- 算法与数据结构（七）：二分查找法总结：[https://blog.csdn.net/Dby_freedom/article/details/94332149](https://blog.csdn.net/Dby_freedom/article/details/94332149)
- 一文带你搞定二分查找及其多个变种：[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/solution/yi-wen-dai-ni-gao-ding-er-fen-cha-zhao-j-ymwl/)