## 1 介绍

「贪心算法」是在基础算法领域真正很「玄」的算法。很难也很简单。它简单在只要能想到，就不难写出来，且代码一般来说逻辑都比较简单，难在证明的算法的合理性，好在绝大多数情况下不要求证明。

贪心算法就像这个世界上的很多定理和猜想一样，需要人先猜测，然后做实验去验证。贪心这个名字有一定「短视」的意味在里面，就是只注重眼前利益，就能达到全局最优。如果用于形容人的话，有一定讽刺意味，但是在算法领域里面，这种思路的确可以解决特定的一类问题。

贪心算法（Greedy Algorithm）是指：在对问题求解时，总是做出在当前看来是最好的选择。也就是不从整体最优上加以考虑，贪心算法所做出决策是在某种意义上的局部最优解。

贪心策略适用的前提是：<font color=#9900CC><strong>局部最优策略能导致产生全局最优解。</font></strong>

可以适用贪心的问题就是每一步局部最优，最后导致结果全局最优。

重点：贪心策略可以使用的前提是和要解决的问题相关的。不是所有的问题都适合使用贪心算法。而判断一个问题是否可以应用贪心算法，可以从以下两个角度：

- 直觉，根据直觉描述出来的算法，具备「只考虑当前，不考虑全局」的特点，那可能就是「贪心算法」；
- 如果不能举出反例，那多半这个问题就具有「贪心算法性质」，可以使用贪心算法去做。

要严格证明「贪心算法」有效，必须使用数学相关的理论，常见的方法有：

- 数学归纳法
- 反证法

贪心算法的证明比较难，并且就算看证明也会给人一头雾水的感觉，就像是让你证明 $\sqrt{2}$ 是无理数一样，但是推翻「贪心算法」很简单。在这里不展开。

经验：由于贪心算法适用的场景一般都是在一组决策里选择最大或者最小值，因此常常在使用贪心算法之前，需要先对数据按照某种规则排序。


一个最简单的理解贪心算法的例子就是「选择排序」，算法描述是：每一轮选择未排定部分里最小的元素交换到未排定部分的开头。

> 说明：对于「选择排序」是否是贪心算法，我查过资料，这一点有争议。我个人认为「选择排序」的算法描述符合「局部最优，则整体最优」，即每一步的决策并不考虑全局，只考虑当下，选这个例子的愿意只是因为它足够简单。 证明「贪心算法」在「选择排序」上有效需要使用「循环不变量」，在这里不展开。

贪心算法不是对所有问题都能够每一步只看当下，选择最好的策略，就得到整体最优解，关键是贪心策略的选择。选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

具备「无后效性」其实在「动态规划」这一类问题里体现得特别明显，大家可以通过贪心算法的学习在具体去理解「无后效性」的意思。

- 当前决策对后面的决策不产生影响；
- 当前决策只需要记录一个结果，而这个决策是怎么来的不重要。

一旦贪心选择性质不成立，可以考虑的另一种算法思想就是「动态规划」。「动态规划」在每一步做决策的时候，就不只考虑当前步骤的最优解。

贪心算法的应用
- 对数据压缩编码的霍夫曼编码（Huffman Coding）
- 求最小生成树的 Prim 算法和 Kruskal 算法
- 求单源最短路径的Dijkstra算法


## 2 真题演练
### 2.1 题库列表
<blockquote> <ul>
<li>「力扣」第 12 题：<a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank">整数转罗马数字</a>，贪心思想更多来源于直觉；</li>
<li>「力扣」第 452 题：<a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank">用最少数量的箭引爆气球</a>，画图发现贪心策略；</li>
<li>「力扣」第 122 题：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank">买卖股票的最佳时机 II</a>，需要简单推导了；</li>
<li>「力扣」第 55 题： <a href="https://leetcode-cn.com/problems/jump-game/" target="_blank">跳跃游戏</a>，画图思考；</li>
<li>「力扣」第 435 题： <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank">无重叠区间</a>，画图思考；</li>
<li>「力扣」第 455 题：<a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank">分发饼干</a>；</li>
<li>「力扣」第 376 题：<a href="https://leetcode.cn/problems/wiggle-subsequence/" target="_blank">摆动序列</a>；</li>
<li>「力扣」第 343 题： <a href="https://leetcode-cn.com/problems/integer-break/" target="_blank">整数拆分</a>，需要简单推导。</li>
<li>「力扣」第 300 题：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank">最长上升子序列</a>，本质上还是动态规划，只不过在推导的过程中发现决策的过程可以贪心进行（具有贪心选择性质）。</li>
</ul></blockquote> 




**455. 分发饼干**

<img src ="https://img-blog.csdnimg.cn/20ea7ea2e11948b0bd8f68179a6c3919.png#pic_center" width = 64%>

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        # 首先要对g 和 s排序：题中没有说明输入是有序序列
        g.sort()
        s.sort()
        # 两个指针分别指向两个列表的末尾
        r_g = len(g) - 1
        r_s = len(s) - 1
        count = 0
        # 循环条件
        while r_g >= 0 and r_s >= 0:
            # 两个指针分别指向两个列表的末尾如果满足`s[r_s] >= g[r_g]`，则都向前移动
            if s[r_s] >= g[r_g]:
                count += 1
                r_g -= 1
                r_s -= 1
            # 否则只需要移动g的指针
            else:
                r_g -= 1
        return count
```

<img src ="https://img-blog.csdnimg.cn/89eeda8dcd3540c08755936993f7b57e.jpeg#pic_center" width = 48%>


**376. 摆动序列**

<img src ="https://img-blog.csdnimg.cn/d87d32a9e2a24dd580f38e77dbc103d3.png#pic_center" width = 48%>

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        preC,curC,res = 0,0,1  #题目里nums长度大于等于1，当长度为1时，其实到不了for循环里去，所以不用考虑nums长度
        for i in range(len(nums) - 1):
            curC = nums[i + 1] - nums[i]
            if curC * preC <= 0 and curC !=0:  #差值为0时，不算摆动
                res += 1
                preC = curC  #如果当前差值和上一个差值为一正一负时，才需要用当前差值替代上一个差值
        return res

作者：代码随想录
链接：https://leetcode.cn/problems/wiggle-subsequence/solutions/518651/376-bai-dong-xu-lie-tan-xin-jing-dian-ti-vyxt/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


______

## 参考
- LC[56] 合并区间————贪心算法：[https://leetcode.cn/problems/merge-intervals/solutions/204898/tan-xin-suan-fa-java-by-liweiwei1419-3/?orderBy=most_votes](https://leetcode.cn/problems/merge-intervals/solutions/204898/tan-xin-suan-fa-java-by-liweiwei1419-3/?orderBy=most_votes)
- 一文通数据结构与算法之——贪心算法+常见题型与解题策略+Leetcode经典题：[https://blog.csdn.net/qq_42647903/article/details/120647495](https://blog.csdn.net/qq_42647903/article/details/120647495)
- 算法刷题总结 (三) 贪心算法：[https://blog.csdn.net/weixin_44225602/article/details/127478415](https://blog.csdn.net/weixin_44225602/article/details/127478415)

